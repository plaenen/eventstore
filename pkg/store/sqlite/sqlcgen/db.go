// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.checkCommandExistsStmt, err = db.PrepareContext(ctx, checkCommandExists); err != nil {
		return nil, fmt.Errorf("error preparing query CheckCommandExists: %w", err)
	}
	if q.claimConstraintStmt, err = db.PrepareContext(ctx, claimConstraint); err != nil {
		return nil, fmt.Errorf("error preparing query ClaimConstraint: %w", err)
	}
	if q.cleanExpiredCommandsStmt, err = db.PrepareContext(ctx, cleanExpiredCommands); err != nil {
		return nil, fmt.Errorf("error preparing query CleanExpiredCommands: %w", err)
	}
	if q.countSnapshotsForAggregateStmt, err = db.PrepareContext(ctx, countSnapshotsForAggregate); err != nil {
		return nil, fmt.Errorf("error preparing query CountSnapshotsForAggregate: %w", err)
	}
	if q.deleteAllConstraintsStmt, err = db.PrepareContext(ctx, deleteAllConstraints); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteAllConstraints: %w", err)
	}
	if q.deleteCheckpointStmt, err = db.PrepareContext(ctx, deleteCheckpoint); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteCheckpoint: %w", err)
	}
	if q.deleteOldSnapshotsStmt, err = db.PrepareContext(ctx, deleteOldSnapshots); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteOldSnapshots: %w", err)
	}
	if q.deleteSnapshotsOlderThanStmt, err = db.PrepareContext(ctx, deleteSnapshotsOlderThan); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteSnapshotsOlderThan: %w", err)
	}
	if q.getAggregateVersionStmt, err = db.PrepareContext(ctx, getAggregateVersion); err != nil {
		return nil, fmt.Errorf("error preparing query GetAggregateVersion: %w", err)
	}
	if q.getAllConstraintsStmt, err = db.PrepareContext(ctx, getAllConstraints); err != nil {
		return nil, fmt.Errorf("error preparing query GetAllConstraints: %w", err)
	}
	if q.getConstraintOwnerStmt, err = db.PrepareContext(ctx, getConstraintOwner); err != nil {
		return nil, fmt.Errorf("error preparing query GetConstraintOwner: %w", err)
	}
	if q.getLatestSnapshotStmt, err = db.PrepareContext(ctx, getLatestSnapshot); err != nil {
		return nil, fmt.Errorf("error preparing query GetLatestSnapshot: %w", err)
	}
	if q.getLatestSnapshotBeforeVersionStmt, err = db.PrepareContext(ctx, getLatestSnapshotBeforeVersion); err != nil {
		return nil, fmt.Errorf("error preparing query GetLatestSnapshotBeforeVersion: %w", err)
	}
	if q.getProcessedCommandStmt, err = db.PrepareContext(ctx, getProcessedCommand); err != nil {
		return nil, fmt.Errorf("error preparing query GetProcessedCommand: %w", err)
	}
	if q.getSnapshotAtVersionStmt, err = db.PrepareContext(ctx, getSnapshotAtVersion); err != nil {
		return nil, fmt.Errorf("error preparing query GetSnapshotAtVersion: %w", err)
	}
	if q.getSnapshotStatsStmt, err = db.PrepareContext(ctx, getSnapshotStats); err != nil {
		return nil, fmt.Errorf("error preparing query GetSnapshotStats: %w", err)
	}
	if q.insertEventStmt, err = db.PrepareContext(ctx, insertEvent); err != nil {
		return nil, fmt.Errorf("error preparing query InsertEvent: %w", err)
	}
	if q.insertProcessedCommandStmt, err = db.PrepareContext(ctx, insertProcessedCommand); err != nil {
		return nil, fmt.Errorf("error preparing query InsertProcessedCommand: %w", err)
	}
	if q.listSnapshotsForAggregateStmt, err = db.PrepareContext(ctx, listSnapshotsForAggregate); err != nil {
		return nil, fmt.Errorf("error preparing query ListSnapshotsForAggregate: %w", err)
	}
	if q.loadAllEventsStmt, err = db.PrepareContext(ctx, loadAllEvents); err != nil {
		return nil, fmt.Errorf("error preparing query LoadAllEvents: %w", err)
	}
	if q.loadCheckpointStmt, err = db.PrepareContext(ctx, loadCheckpoint); err != nil {
		return nil, fmt.Errorf("error preparing query LoadCheckpoint: %w", err)
	}
	if q.loadEventByIDStmt, err = db.PrepareContext(ctx, loadEventByID); err != nil {
		return nil, fmt.Errorf("error preparing query LoadEventByID: %w", err)
	}
	if q.loadEventsStmt, err = db.PrepareContext(ctx, loadEvents); err != nil {
		return nil, fmt.Errorf("error preparing query LoadEvents: %w", err)
	}
	if q.releaseConstraintStmt, err = db.PrepareContext(ctx, releaseConstraint); err != nil {
		return nil, fmt.Errorf("error preparing query ReleaseConstraint: %w", err)
	}
	if q.saveCheckpointStmt, err = db.PrepareContext(ctx, saveCheckpoint); err != nil {
		return nil, fmt.Errorf("error preparing query SaveCheckpoint: %w", err)
	}
	if q.saveSnapshotStmt, err = db.PrepareContext(ctx, saveSnapshot); err != nil {
		return nil, fmt.Errorf("error preparing query SaveSnapshot: %w", err)
	}
	if q.updateEventPositionsStmt, err = db.PrepareContext(ctx, updateEventPositions); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateEventPositions: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.checkCommandExistsStmt != nil {
		if cerr := q.checkCommandExistsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing checkCommandExistsStmt: %w", cerr)
		}
	}
	if q.claimConstraintStmt != nil {
		if cerr := q.claimConstraintStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing claimConstraintStmt: %w", cerr)
		}
	}
	if q.cleanExpiredCommandsStmt != nil {
		if cerr := q.cleanExpiredCommandsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing cleanExpiredCommandsStmt: %w", cerr)
		}
	}
	if q.countSnapshotsForAggregateStmt != nil {
		if cerr := q.countSnapshotsForAggregateStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing countSnapshotsForAggregateStmt: %w", cerr)
		}
	}
	if q.deleteAllConstraintsStmt != nil {
		if cerr := q.deleteAllConstraintsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteAllConstraintsStmt: %w", cerr)
		}
	}
	if q.deleteCheckpointStmt != nil {
		if cerr := q.deleteCheckpointStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteCheckpointStmt: %w", cerr)
		}
	}
	if q.deleteOldSnapshotsStmt != nil {
		if cerr := q.deleteOldSnapshotsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteOldSnapshotsStmt: %w", cerr)
		}
	}
	if q.deleteSnapshotsOlderThanStmt != nil {
		if cerr := q.deleteSnapshotsOlderThanStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteSnapshotsOlderThanStmt: %w", cerr)
		}
	}
	if q.getAggregateVersionStmt != nil {
		if cerr := q.getAggregateVersionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getAggregateVersionStmt: %w", cerr)
		}
	}
	if q.getAllConstraintsStmt != nil {
		if cerr := q.getAllConstraintsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getAllConstraintsStmt: %w", cerr)
		}
	}
	if q.getConstraintOwnerStmt != nil {
		if cerr := q.getConstraintOwnerStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getConstraintOwnerStmt: %w", cerr)
		}
	}
	if q.getLatestSnapshotStmt != nil {
		if cerr := q.getLatestSnapshotStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getLatestSnapshotStmt: %w", cerr)
		}
	}
	if q.getLatestSnapshotBeforeVersionStmt != nil {
		if cerr := q.getLatestSnapshotBeforeVersionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getLatestSnapshotBeforeVersionStmt: %w", cerr)
		}
	}
	if q.getProcessedCommandStmt != nil {
		if cerr := q.getProcessedCommandStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getProcessedCommandStmt: %w", cerr)
		}
	}
	if q.getSnapshotAtVersionStmt != nil {
		if cerr := q.getSnapshotAtVersionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getSnapshotAtVersionStmt: %w", cerr)
		}
	}
	if q.getSnapshotStatsStmt != nil {
		if cerr := q.getSnapshotStatsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getSnapshotStatsStmt: %w", cerr)
		}
	}
	if q.insertEventStmt != nil {
		if cerr := q.insertEventStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertEventStmt: %w", cerr)
		}
	}
	if q.insertProcessedCommandStmt != nil {
		if cerr := q.insertProcessedCommandStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertProcessedCommandStmt: %w", cerr)
		}
	}
	if q.listSnapshotsForAggregateStmt != nil {
		if cerr := q.listSnapshotsForAggregateStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listSnapshotsForAggregateStmt: %w", cerr)
		}
	}
	if q.loadAllEventsStmt != nil {
		if cerr := q.loadAllEventsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing loadAllEventsStmt: %w", cerr)
		}
	}
	if q.loadCheckpointStmt != nil {
		if cerr := q.loadCheckpointStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing loadCheckpointStmt: %w", cerr)
		}
	}
	if q.loadEventByIDStmt != nil {
		if cerr := q.loadEventByIDStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing loadEventByIDStmt: %w", cerr)
		}
	}
	if q.loadEventsStmt != nil {
		if cerr := q.loadEventsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing loadEventsStmt: %w", cerr)
		}
	}
	if q.releaseConstraintStmt != nil {
		if cerr := q.releaseConstraintStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing releaseConstraintStmt: %w", cerr)
		}
	}
	if q.saveCheckpointStmt != nil {
		if cerr := q.saveCheckpointStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing saveCheckpointStmt: %w", cerr)
		}
	}
	if q.saveSnapshotStmt != nil {
		if cerr := q.saveSnapshotStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing saveSnapshotStmt: %w", cerr)
		}
	}
	if q.updateEventPositionsStmt != nil {
		if cerr := q.updateEventPositionsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateEventPositionsStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                                 DBTX
	tx                                 *sql.Tx
	checkCommandExistsStmt             *sql.Stmt
	claimConstraintStmt                *sql.Stmt
	cleanExpiredCommandsStmt           *sql.Stmt
	countSnapshotsForAggregateStmt     *sql.Stmt
	deleteAllConstraintsStmt           *sql.Stmt
	deleteCheckpointStmt               *sql.Stmt
	deleteOldSnapshotsStmt             *sql.Stmt
	deleteSnapshotsOlderThanStmt       *sql.Stmt
	getAggregateVersionStmt            *sql.Stmt
	getAllConstraintsStmt              *sql.Stmt
	getConstraintOwnerStmt             *sql.Stmt
	getLatestSnapshotStmt              *sql.Stmt
	getLatestSnapshotBeforeVersionStmt *sql.Stmt
	getProcessedCommandStmt            *sql.Stmt
	getSnapshotAtVersionStmt           *sql.Stmt
	getSnapshotStatsStmt               *sql.Stmt
	insertEventStmt                    *sql.Stmt
	insertProcessedCommandStmt         *sql.Stmt
	listSnapshotsForAggregateStmt      *sql.Stmt
	loadAllEventsStmt                  *sql.Stmt
	loadCheckpointStmt                 *sql.Stmt
	loadEventByIDStmt                  *sql.Stmt
	loadEventsStmt                     *sql.Stmt
	releaseConstraintStmt              *sql.Stmt
	saveCheckpointStmt                 *sql.Stmt
	saveSnapshotStmt                   *sql.Stmt
	updateEventPositionsStmt           *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                                 tx,
		tx:                                 tx,
		checkCommandExistsStmt:             q.checkCommandExistsStmt,
		claimConstraintStmt:                q.claimConstraintStmt,
		cleanExpiredCommandsStmt:           q.cleanExpiredCommandsStmt,
		countSnapshotsForAggregateStmt:     q.countSnapshotsForAggregateStmt,
		deleteAllConstraintsStmt:           q.deleteAllConstraintsStmt,
		deleteCheckpointStmt:               q.deleteCheckpointStmt,
		deleteOldSnapshotsStmt:             q.deleteOldSnapshotsStmt,
		deleteSnapshotsOlderThanStmt:       q.deleteSnapshotsOlderThanStmt,
		getAggregateVersionStmt:            q.getAggregateVersionStmt,
		getAllConstraintsStmt:              q.getAllConstraintsStmt,
		getConstraintOwnerStmt:             q.getConstraintOwnerStmt,
		getLatestSnapshotStmt:              q.getLatestSnapshotStmt,
		getLatestSnapshotBeforeVersionStmt: q.getLatestSnapshotBeforeVersionStmt,
		getProcessedCommandStmt:            q.getProcessedCommandStmt,
		getSnapshotAtVersionStmt:           q.getSnapshotAtVersionStmt,
		getSnapshotStatsStmt:               q.getSnapshotStatsStmt,
		insertEventStmt:                    q.insertEventStmt,
		insertProcessedCommandStmt:         q.insertProcessedCommandStmt,
		listSnapshotsForAggregateStmt:      q.listSnapshotsForAggregateStmt,
		loadAllEventsStmt:                  q.loadAllEventsStmt,
		loadCheckpointStmt:                 q.loadCheckpointStmt,
		loadEventByIDStmt:                  q.loadEventByIDStmt,
		loadEventsStmt:                     q.loadEventsStmt,
		releaseConstraintStmt:              q.releaseConstraintStmt,
		saveCheckpointStmt:                 q.saveCheckpointStmt,
		saveSnapshotStmt:                   q.saveSnapshotStmt,
		updateEventPositionsStmt:           q.updateEventPositionsStmt,
	}
}
