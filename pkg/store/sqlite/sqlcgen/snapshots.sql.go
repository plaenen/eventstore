// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: snapshots.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const countSnapshotsForAggregate = `-- name: CountSnapshotsForAggregate :one
SELECT COUNT(*) FROM snapshots
WHERE aggregate_id = ?
`

func (q *Queries) CountSnapshotsForAggregate(ctx context.Context, aggregateID string) (int64, error) {
	row := q.queryRow(ctx, q.countSnapshotsForAggregateStmt, countSnapshotsForAggregate, aggregateID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldSnapshots = `-- name: DeleteOldSnapshots :exec
DELETE FROM snapshots
WHERE aggregate_id = ? AND version < ?
`

type DeleteOldSnapshotsParams struct {
	AggregateID string `json:"aggregate_id"`
	Version     int64  `json:"version"`
}

// Deletes snapshots older than a specific version for an aggregate
func (q *Queries) DeleteOldSnapshots(ctx context.Context, arg DeleteOldSnapshotsParams) error {
	_, err := q.exec(ctx, q.deleteOldSnapshotsStmt, deleteOldSnapshots, arg.AggregateID, arg.Version)
	return err
}

const deleteSnapshotsOlderThan = `-- name: DeleteSnapshotsOlderThan :exec
DELETE FROM snapshots
WHERE created_at < ?
`

func (q *Queries) DeleteSnapshotsOlderThan(ctx context.Context, createdAt int64) error {
	_, err := q.exec(ctx, q.deleteSnapshotsOlderThanStmt, deleteSnapshotsOlderThan, createdAt)
	return err
}

const getLatestSnapshot = `-- name: GetLatestSnapshot :one
SELECT aggregate_id, aggregate_type, version, data, created_at, metadata
FROM snapshots
WHERE aggregate_id = ?
ORDER BY version DESC
LIMIT 1
`

func (q *Queries) GetLatestSnapshot(ctx context.Context, aggregateID string) (Snapshot, error) {
	row := q.queryRow(ctx, q.getLatestSnapshotStmt, getLatestSnapshot, aggregateID)
	var i Snapshot
	err := row.Scan(
		&i.AggregateID,
		&i.AggregateType,
		&i.Version,
		&i.Data,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

const getLatestSnapshotBeforeVersion = `-- name: GetLatestSnapshotBeforeVersion :one
SELECT aggregate_id, aggregate_type, version, data, created_at, metadata
FROM snapshots
WHERE aggregate_id = ? AND version <= ?
ORDER BY version DESC
LIMIT 1
`

type GetLatestSnapshotBeforeVersionParams struct {
	AggregateID string `json:"aggregate_id"`
	Version     int64  `json:"version"`
}

func (q *Queries) GetLatestSnapshotBeforeVersion(ctx context.Context, arg GetLatestSnapshotBeforeVersionParams) (Snapshot, error) {
	row := q.queryRow(ctx, q.getLatestSnapshotBeforeVersionStmt, getLatestSnapshotBeforeVersion, arg.AggregateID, arg.Version)
	var i Snapshot
	err := row.Scan(
		&i.AggregateID,
		&i.AggregateType,
		&i.Version,
		&i.Data,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

const getSnapshotAtVersion = `-- name: GetSnapshotAtVersion :one
SELECT aggregate_id, aggregate_type, version, data, created_at, metadata
FROM snapshots
WHERE aggregate_id = ? AND version = ?
`

type GetSnapshotAtVersionParams struct {
	AggregateID string `json:"aggregate_id"`
	Version     int64  `json:"version"`
}

func (q *Queries) GetSnapshotAtVersion(ctx context.Context, arg GetSnapshotAtVersionParams) (Snapshot, error) {
	row := q.queryRow(ctx, q.getSnapshotAtVersionStmt, getSnapshotAtVersion, arg.AggregateID, arg.Version)
	var i Snapshot
	err := row.Scan(
		&i.AggregateID,
		&i.AggregateType,
		&i.Version,
		&i.Data,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

const getSnapshotStats = `-- name: GetSnapshotStats :one
SELECT
    COUNT(*) as total_snapshots,
    COUNT(DISTINCT aggregate_id) as unique_aggregates,
    SUM(LENGTH(data)) as total_size_bytes,
    AVG(LENGTH(data)) as avg_size_bytes,
    MIN(created_at) as oldest_snapshot,
    MAX(created_at) as newest_snapshot
FROM snapshots
`

type GetSnapshotStatsRow struct {
	TotalSnapshots   int64           `json:"total_snapshots"`
	UniqueAggregates int64           `json:"unique_aggregates"`
	TotalSizeBytes   sql.NullFloat64 `json:"total_size_bytes"`
	AvgSizeBytes     sql.NullFloat64 `json:"avg_size_bytes"`
	OldestSnapshot   interface{}     `json:"oldest_snapshot"`
	NewestSnapshot   interface{}     `json:"newest_snapshot"`
}

func (q *Queries) GetSnapshotStats(ctx context.Context) (GetSnapshotStatsRow, error) {
	row := q.queryRow(ctx, q.getSnapshotStatsStmt, getSnapshotStats)
	var i GetSnapshotStatsRow
	err := row.Scan(
		&i.TotalSnapshots,
		&i.UniqueAggregates,
		&i.TotalSizeBytes,
		&i.AvgSizeBytes,
		&i.OldestSnapshot,
		&i.NewestSnapshot,
	)
	return i, err
}

const listSnapshotsForAggregate = `-- name: ListSnapshotsForAggregate :many
SELECT aggregate_id, aggregate_type, version, data, created_at, metadata
FROM snapshots
WHERE aggregate_id = ?
ORDER BY version DESC
`

func (q *Queries) ListSnapshotsForAggregate(ctx context.Context, aggregateID string) ([]Snapshot, error) {
	rows, err := q.query(ctx, q.listSnapshotsForAggregateStmt, listSnapshotsForAggregate, aggregateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Snapshot{}
	for rows.Next() {
		var i Snapshot
		if err := rows.Scan(
			&i.AggregateID,
			&i.AggregateType,
			&i.Version,
			&i.Data,
			&i.CreatedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveSnapshot = `-- name: SaveSnapshot :exec
INSERT INTO snapshots (aggregate_id, aggregate_type, version, data, created_at, metadata)
VALUES (?, ?, ?, ?, ?, ?)
`

type SaveSnapshotParams struct {
	AggregateID   string         `json:"aggregate_id"`
	AggregateType string         `json:"aggregate_type"`
	Version       int64          `json:"version"`
	Data          []byte         `json:"data"`
	CreatedAt     int64          `json:"created_at"`
	Metadata      sql.NullString `json:"metadata"`
}

func (q *Queries) SaveSnapshot(ctx context.Context, arg SaveSnapshotParams) error {
	_, err := q.exec(ctx, q.saveSnapshotStmt, saveSnapshot,
		arg.AggregateID,
		arg.AggregateType,
		arg.Version,
		arg.Data,
		arg.CreatedAt,
		arg.Metadata,
	)
	return err
}
