// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: constraints.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const claimConstraint = `-- name: ClaimConstraint :exec
INSERT OR REPLACE INTO unique_constraints (index_name, value, aggregate_id, created_at)
VALUES (?, ?, ?, ?)
`

type ClaimConstraintParams struct {
	IndexName   string `json:"index_name"`
	Value       string `json:"value"`
	AggregateID string `json:"aggregate_id"`
	CreatedAt   int64  `json:"created_at"`
}

func (q *Queries) ClaimConstraint(ctx context.Context, arg ClaimConstraintParams) error {
	_, err := q.exec(ctx, q.claimConstraintStmt, claimConstraint,
		arg.IndexName,
		arg.Value,
		arg.AggregateID,
		arg.CreatedAt,
	)
	return err
}

const deleteAllConstraints = `-- name: DeleteAllConstraints :exec
DELETE FROM unique_constraints
`

func (q *Queries) DeleteAllConstraints(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteAllConstraintsStmt, deleteAllConstraints)
	return err
}

const getAllConstraints = `-- name: GetAllConstraints :many
SELECT aggregate_id, constraints
FROM events
ORDER BY position ASC
`

type GetAllConstraintsRow struct {
	AggregateID string         `json:"aggregate_id"`
	Constraints sql.NullString `json:"constraints"`
}

func (q *Queries) GetAllConstraints(ctx context.Context) ([]GetAllConstraintsRow, error) {
	rows, err := q.query(ctx, q.getAllConstraintsStmt, getAllConstraints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllConstraintsRow{}
	for rows.Next() {
		var i GetAllConstraintsRow
		if err := rows.Scan(&i.AggregateID, &i.Constraints); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConstraintOwner = `-- name: GetConstraintOwner :one
SELECT aggregate_id
FROM unique_constraints
WHERE index_name = ? AND value = ?
`

type GetConstraintOwnerParams struct {
	IndexName string `json:"index_name"`
	Value     string `json:"value"`
}

func (q *Queries) GetConstraintOwner(ctx context.Context, arg GetConstraintOwnerParams) (string, error) {
	row := q.queryRow(ctx, q.getConstraintOwnerStmt, getConstraintOwner, arg.IndexName, arg.Value)
	var aggregate_id string
	err := row.Scan(&aggregate_id)
	return aggregate_id, err
}

const releaseConstraint = `-- name: ReleaseConstraint :exec
DELETE FROM unique_constraints
WHERE index_name = ? AND value = ? AND aggregate_id = ?
`

type ReleaseConstraintParams struct {
	IndexName   string `json:"index_name"`
	Value       string `json:"value"`
	AggregateID string `json:"aggregate_id"`
}

func (q *Queries) ReleaseConstraint(ctx context.Context, arg ReleaseConstraintParams) error {
	_, err := q.exec(ctx, q.releaseConstraintStmt, releaseConstraint, arg.IndexName, arg.Value, arg.AggregateID)
	return err
}
