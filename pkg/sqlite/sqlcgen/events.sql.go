// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const getAggregateVersion = `-- name: GetAggregateVersion :one
SELECT COALESCE(MAX(version), 0) AS version
FROM events
WHERE aggregate_id = ?
`

func (q *Queries) GetAggregateVersion(ctx context.Context, aggregateID string) (interface{}, error) {
	row := q.queryRow(ctx, q.getAggregateVersionStmt, getAggregateVersion, aggregateID)
	var version interface{}
	err := row.Scan(&version)
	return version, err
}

const insertEvent = `-- name: InsertEvent :exec
INSERT INTO events (
    event_id, aggregate_id, aggregate_type, event_type,
    version, timestamp, data, metadata, constraints, position
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NULL)
`

type InsertEventParams struct {
	EventID       string         `json:"event_id"`
	AggregateID   string         `json:"aggregate_id"`
	AggregateType string         `json:"aggregate_type"`
	EventType     string         `json:"event_type"`
	Version       int64          `json:"version"`
	Timestamp     int64          `json:"timestamp"`
	Data          []byte         `json:"data"`
	Metadata      string         `json:"metadata"`
	Constraints   sql.NullString `json:"constraints"`
}

func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) error {
	_, err := q.exec(ctx, q.insertEventStmt, insertEvent,
		arg.EventID,
		arg.AggregateID,
		arg.AggregateType,
		arg.EventType,
		arg.Version,
		arg.Timestamp,
		arg.Data,
		arg.Metadata,
		arg.Constraints,
	)
	return err
}

const loadAllEvents = `-- name: LoadAllEvents :many
SELECT event_id, aggregate_id, aggregate_type, event_type,
       version, timestamp, data, metadata, constraints, position
FROM events
WHERE position >= ?
ORDER BY position ASC
LIMIT ?
`

type LoadAllEventsParams struct {
	Position sql.NullInt64 `json:"position"`
	Limit    int64         `json:"limit"`
}

func (q *Queries) LoadAllEvents(ctx context.Context, arg LoadAllEventsParams) ([]Event, error) {
	rows, err := q.query(ctx, q.loadAllEventsStmt, loadAllEvents, arg.Position, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.AggregateID,
			&i.AggregateType,
			&i.EventType,
			&i.Version,
			&i.Timestamp,
			&i.Data,
			&i.Metadata,
			&i.Constraints,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadEventByID = `-- name: LoadEventByID :one
SELECT event_id, aggregate_id, aggregate_type, event_type,
       version, timestamp, data, metadata, constraints
FROM events
WHERE event_id = ?
`

type LoadEventByIDRow struct {
	EventID       string         `json:"event_id"`
	AggregateID   string         `json:"aggregate_id"`
	AggregateType string         `json:"aggregate_type"`
	EventType     string         `json:"event_type"`
	Version       int64          `json:"version"`
	Timestamp     int64          `json:"timestamp"`
	Data          []byte         `json:"data"`
	Metadata      string         `json:"metadata"`
	Constraints   sql.NullString `json:"constraints"`
}

func (q *Queries) LoadEventByID(ctx context.Context, eventID string) (LoadEventByIDRow, error) {
	row := q.queryRow(ctx, q.loadEventByIDStmt, loadEventByID, eventID)
	var i LoadEventByIDRow
	err := row.Scan(
		&i.EventID,
		&i.AggregateID,
		&i.AggregateType,
		&i.EventType,
		&i.Version,
		&i.Timestamp,
		&i.Data,
		&i.Metadata,
		&i.Constraints,
	)
	return i, err
}

const loadEvents = `-- name: LoadEvents :many
SELECT event_id, aggregate_id, aggregate_type, event_type,
       version, timestamp, data, metadata, constraints
FROM events
WHERE aggregate_id = ? AND version > ?
ORDER BY version ASC
`

type LoadEventsParams struct {
	AggregateID string `json:"aggregate_id"`
	Version     int64  `json:"version"`
}

type LoadEventsRow struct {
	EventID       string         `json:"event_id"`
	AggregateID   string         `json:"aggregate_id"`
	AggregateType string         `json:"aggregate_type"`
	EventType     string         `json:"event_type"`
	Version       int64          `json:"version"`
	Timestamp     int64          `json:"timestamp"`
	Data          []byte         `json:"data"`
	Metadata      string         `json:"metadata"`
	Constraints   sql.NullString `json:"constraints"`
}

func (q *Queries) LoadEvents(ctx context.Context, arg LoadEventsParams) ([]LoadEventsRow, error) {
	rows, err := q.query(ctx, q.loadEventsStmt, loadEvents, arg.AggregateID, arg.Version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoadEventsRow{}
	for rows.Next() {
		var i LoadEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.AggregateID,
			&i.AggregateType,
			&i.EventType,
			&i.Version,
			&i.Timestamp,
			&i.Data,
			&i.Metadata,
			&i.Constraints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventPositions = `-- name: UpdateEventPositions :exec
UPDATE events
SET position = (
    SELECT COUNT(*)
    FROM events e2
    WHERE e2.timestamp < events.timestamp
       OR (e2.timestamp = events.timestamp AND e2.event_id <= events.event_id)
)
WHERE position IS NULL
`

func (q *Queries) UpdateEventPositions(ctx context.Context) error {
	_, err := q.exec(ctx, q.updateEventPositionsStmt, updateEventPositions)
	return err
}
