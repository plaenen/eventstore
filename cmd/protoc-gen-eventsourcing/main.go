// protoc-gen-eventsourcing generates event sourcing boilerplate from proto files.
//
// This plugin generates:
//   - Aggregate root structs based on proto messages marked with (eventsourcing.aggregate_root)
//   - Command handler helper methods
//   - Event applier methods
//   - Type-safe repositories
//
// Configuration via Proto Options:
//
// The plugin uses custom proto options (defined in eventsourcing/options.proto):
//
//   - Message option: (eventsourcing.aggregate_root) marks a proto message as an aggregate
//   - Message option: (eventsourcing.event_options) configures event-to-state mapping
//   - Message option: (eventsourcing.aggregate_options) for commands (produces_events, constraints)
//   - Service option: (eventsourcing.aggregate_name) = "AggregateName"
package main

import (
	"flag"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			generateFile(gen, f)
		}

		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	// Check if there are any aggregates, commands, or events to generate
	aggregates := findAggregates(file)
	commands := findCommands(file)
	hasEvents := false
	for _, agg := range aggregates {
		events := findEventsForAggregate(file, agg.TypeName)
		if len(events) > 0 {
			hasEvents = true
			break
		}
	}

	// Skip files that don't have anything to generate
	if len(aggregates) == 0 && len(commands) == 0 && !hasEvents {
		return
	}

	// Generate aggregate file
	aggregateFilename := file.GeneratedFilenamePrefix + "_aggregate.pb.go"
	g := gen.NewGeneratedFile(aggregateFilename, file.GoImportPath)

	generateHeader(g, file)
	generateAggregates(g, file)
	generateCommandHandlers(g, file)
	generateEventAppliers(g, file)
	generateRepository(g, file)
}

func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"fmt"`)
	g.P(`	"time"`)
	g.P()
	g.P(`	"github.com/plaenen/eventsourcing/pkg/eventsourcing"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()
}

func generateAggregates(g *protogen.GeneratedFile, file *protogen.File) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		aggregateType := agg.TypeName + "Aggregate"

		g.P("// ", aggregateType, " is the aggregate root for ", agg.TypeName, " domain")
		g.P("// It embeds the proto-defined ", agg.MessageName, " for state management")
		g.P("type ", aggregateType, " struct {")
		g.P("	eventsourcing.AggregateRoot")
		g.P("	*", agg.MessageName)
		g.P("}")
		g.P()

		// Constructor
		g.P("// New", agg.TypeName, " creates a new ", aggregateType, " instance")
		g.P("func New", agg.TypeName, "(id string) *", aggregateType, " {")
		g.P("	return &", aggregateType, "{")
		g.P("		AggregateRoot: eventsourcing.NewAggregateRoot(id, \"", agg.TypeName, "\"),")
		g.P("		", agg.MessageName, ": &", agg.MessageName, "{},")
		g.P("	}")
		g.P("}")
		g.P()

		// Snapshot support
		g.P("// MarshalSnapshot serializes the aggregate state for snapshots")
		g.P("func (a *", aggregateType, ") MarshalSnapshot() ([]byte, error) {")
		g.P("	return proto.Marshal(a.", agg.MessageName, ")")
		g.P("}")
		g.P()

		g.P("// UnmarshalSnapshot deserializes the aggregate state from snapshots")
		g.P("func (a *", aggregateType, ") UnmarshalSnapshot(data []byte) error {")
		g.P("	a.", agg.MessageName, " = &", agg.MessageName, "{}")
		g.P("	return proto.Unmarshal(data, a.", agg.MessageName, ")")
		g.P("}")
		g.P()

		// Helper to get ID from aggregate
		g.P("// ID returns the aggregate ID")
		g.P("func (a *", aggregateType, ") ID() string {")
		g.P("	return a.", agg.IDFieldGo)
		g.P("}")
		g.P()

		// Helper to get Type
		g.P("// Type returns the aggregate type name")
		g.P("func (a *", aggregateType, ") Type() string {")
		g.P("	return \"", agg.TypeName, "\"")
		g.P("}")
		g.P()
	}
}

func generateCommandHandlers(g *protogen.GeneratedFile, file *protogen.File) {
	aggregates := findAggregates(file)

	if len(aggregates) == 0 {
		return
	}

	// Find commands and their associated events
	commands := findCommands(file)

	for _, cmd := range commands {
		aggregateName := cmd.AggregateName

		// Find the aggregate
		var agg *AggregateInfo
		for _, a := range aggregates {
			if a.TypeName == aggregateName {
				agg = a
				break
			}
		}
		if agg == nil {
			continue
		}

		aggregateType := agg.TypeName + "Aggregate"

		// Generate helper methods for each event the command produces
		for _, eventName := range cmd.ProducesEvents {
			g.P("// Emit", eventName, " is a helper to emit ", eventName, " after validation")
			g.P("// Call this from your custom ", cmd.MethodName, " implementation")
			g.P("func (a *", aggregateType, ") Emit", eventName, "(event *", eventName, ", metadata eventsourcing.EventMetadata) error {")

			if len(cmd.UniqueConstraints) > 0 {
				g.P("	constraints := []eventsourcing.UniqueConstraint{")
				for _, constraint := range cmd.UniqueConstraints {
					g.P("		{")
					g.P("			IndexName: \"", constraint.IndexName, "\",")
					g.P("			Value: event.", constraint.FieldGo, ",")
					g.P("			Operation: eventsourcing.Constraint", strings.Title(strings.ToLower(constraint.Operation)), ",")
					g.P("		},")
				}
				g.P("	}")
				g.P("	return a.ApplyChangeWithConstraints(event, \"", file.GoPackageName, ".", eventName, "\", metadata, constraints)")
			} else {
				g.P("	return a.ApplyChange(event, \"", file.GoPackageName, ".", eventName, "\", metadata)")
			}

			g.P("}")
			g.P()
		}
	}
}

func generateEventAppliers(g *protogen.GeneratedFile, file *protogen.File) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		aggregateType := agg.TypeName + "Aggregate"
		events := findEventsForAggregate(file, agg.TypeName)

		if len(events) == 0 {
			continue
		}

		g.P("// ApplyEvent applies an event to the ", agg.TypeName, " aggregate")
		g.P("func (a *", aggregateType, ") ApplyEvent(event proto.Message) error {")
		g.P("	switch e := event.(type) {")

		for _, evt := range events {
			g.P("	case *", evt.MessageName, ":")
			g.P("		return a.apply", evt.MessageName, "(e)")
		}

		g.P("	default:")
		g.P("		return fmt.Errorf(\"unknown event type: %T\", event)")
		g.P("	}")
		g.P("}")
		g.P()

		// Generate individual appliers
		for _, evt := range events {
			g.P("func (a *", aggregateType, ") apply", evt.MessageName, "(e *", evt.MessageName, ") error {")

			// Apply field mappings and state updates
			if len(evt.AppliesToState) > 0 {
				for _, stateField := range evt.AppliesToState {
					// Check if there's a field mapping
					eventField := stateField
					if mappedField, ok := evt.FieldMapping[stateField]; ok {
						eventField = mappedField
					}

					// Convert to Go field names
					stateFieldGo := toGoName(stateField)
					eventFieldGo := toGoName(eventField)

					g.P("	a.", stateFieldGo, " = e.", eventFieldGo)
				}
			} else {
				g.P("	// TODO: Manually update aggregate state from event fields")
			}

			// Special handling for status changes
			if strings.Contains(evt.MessageName, "Closed") {
				// Try to find status enum
				if hasField(agg.Message, "status") {
					statusType := getFieldType(agg.Message, "status")
					g.P("	a.Status = ", statusType, "_", strings.ToUpper(agg.TypeName), "_STATUS_CLOSED")
				}
			} else if strings.Contains(evt.MessageName, "Opened") || strings.Contains(evt.MessageName, "Created") {
				if hasField(agg.Message, "status") {
					statusType := getFieldType(agg.Message, "status")
					g.P("	a.Status = ", statusType, "_", strings.ToUpper(agg.TypeName), "_STATUS_OPEN")
				}
			}

			g.P("	return nil")
			g.P("}")
			g.P()
		}
	}
}

func generateRepository(g *protogen.GeneratedFile, file *protogen.File) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		aggregateType := agg.TypeName + "Aggregate"
		repoName := agg.TypeName + "Repository"

		g.P("// ", repoName, " provides persistence for ", agg.TypeName)
		g.P("type ", repoName, " struct {")
		g.P("	*eventsourcing.BaseRepository[*", aggregateType, "]")
		g.P("}")
		g.P()

		g.P("// New", repoName, " creates a new repository")
		g.P("func New", repoName, "(eventStore eventsourcing.EventStore) *", repoName, " {")
		g.P("	return &", repoName, "{")
		g.P("		BaseRepository: eventsourcing.NewRepository[*", aggregateType, "](")
		g.P("			eventStore,")
		g.P(`			"`, agg.TypeName, `",`)
		g.P("			func(id string) *", aggregateType, " {")
		g.P("				return New", agg.TypeName, "(id)")
		g.P("			},")
		g.P("			func(agg *", aggregateType, ", event *eventsourcing.Event) error {")
		g.P("				// Deserialize and apply event")
		g.P("				msg, err := deserializeEvent", agg.TypeName, "(event)")
		g.P("				if err != nil {")
		g.P("					return err")
		g.P("				}")
		g.P("				return agg.ApplyEvent(msg)")
		g.P("			},")
		g.P("		),")
		g.P("	}")
		g.P("}")
		g.P()

		// Deserializer helper
		events := findEventsForAggregate(file, agg.TypeName)

		g.P("func deserializeEvent", agg.TypeName, "(event *eventsourcing.Event) (proto.Message, error) {")
		g.P("	switch event.EventType {")

		for _, evt := range events {
			fullName := string(file.GoPackageName) + "." + evt.MessageName
			g.P("	case \"", fullName, "\":")
			g.P("		msg := &", evt.MessageName, "{}")
			g.P("		if err := proto.Unmarshal(event.Data, msg); err != nil {")
			g.P("			return nil, err")
			g.P("		}")
			g.P("		return msg, nil")
		}

		g.P("	default:")
		g.P("		return nil, fmt.Errorf(\"unknown event type: %s\", event.EventType)")
		g.P("	}")
		g.P("}")
		g.P()
	}
}

// Helper types

type AggregateInfo struct {
	Message     *protogen.Message
	MessageName string
	TypeName    string
	IDField     string
	IDFieldGo   string
}

type CommandInfo struct {
	MessageName       string
	MethodName        string
	AggregateName     string
	ProducesEvents    []string
	UniqueConstraints []ConstraintInfo
}

type EventInfo struct {
	MessageName    string
	AggregateName  string
	AppliesToState []string
	FieldMapping   map[string]string
}

type ConstraintInfo struct {
	IndexName string
	Field     string
	FieldGo   string
	Operation string
}

func findAggregates(file *protogen.File) []*AggregateInfo {
	var aggregates []*AggregateInfo

	// Look for proto messages that match aggregate pattern
	// For now, look for messages that don't end in Command, Event, Request, Response, View
	for _, msg := range file.Messages {
		name := string(msg.Desc.Name())

		// Skip non-aggregate messages
		if strings.HasSuffix(name, "Command") ||
			strings.HasSuffix(name, "Event") ||
			strings.HasSuffix(name, "Request") ||
			strings.HasSuffix(name, "Response") ||
			strings.HasSuffix(name, "View") ||
			strings.HasSuffix(name, "Snapshot") {
			continue
		}

		// Check if this message has an ID field (heuristic for aggregate)
		idField := ""
		idFieldGo := ""
		for _, field := range msg.Fields {
			fieldName := string(field.Desc.Name())
			if strings.HasSuffix(fieldName, "_id") {
				idField = fieldName
				idFieldGo = field.GoName
				break
			}
		}

		if idField != "" {
			aggregates = append(aggregates, &AggregateInfo{
				Message:     msg,
				MessageName: name,
				TypeName:    name,
				IDField:     idField,
				IDFieldGo:   idFieldGo,
			})
		}
	}

	// Fallback to service-based detection if no aggregates found
	if len(aggregates) == 0 {
		aggregates = findAggregatesFromServices(file)
	}

	return aggregates
}

func findCommands(file *protogen.File) []*CommandInfo {
	var commands []*CommandInfo

	// Find aggregate name from service
	aggregateName := ""
	for _, svc := range file.Services {
		name := string(svc.Desc.Name())
		if strings.HasSuffix(name, "CommandService") {
			aggregateName = strings.TrimSuffix(name, "CommandService")
			break
		}
	}

	for _, msg := range file.Messages {
		if !strings.HasSuffix(string(msg.Desc.Name()), "Command") {
			continue
		}

		commands = append(commands, &CommandInfo{
			MessageName:       string(msg.Desc.Name()),
			MethodName:        extractMethodName(string(msg.Desc.Name())),
			AggregateName:     aggregateName,
			ProducesEvents:    []string{inferEventName(string(msg.Desc.Name()))},
			UniqueConstraints: []ConstraintInfo{},
		})
	}

	return commands
}

func findEventsForAggregate(file *protogen.File, aggregateName string) []*EventInfo {
	var events []*EventInfo

	for _, msg := range file.Messages {
		if !strings.HasSuffix(string(msg.Desc.Name()), "Event") {
			continue
		}

		// Simple heuristic: if event name contains aggregate name, it belongs to that aggregate
		eventName := string(msg.Desc.Name())
		if strings.Contains(eventName, aggregateName) || aggregateName == "" {
			events = append(events, &EventInfo{
				MessageName:    eventName,
				AggregateName:  aggregateName,
				AppliesToState: extractStateFieldsFromEvent(msg),
				FieldMapping:   make(map[string]string),
			})
		}
	}

	return events
}

func extractStateFieldsFromEvent(msg *protogen.Message) []string {
	var fields []string
	for _, field := range msg.Fields {
		fieldName := string(field.Desc.Name())
		if fieldName != "timestamp" && fieldName != "version" {
			fields = append(fields, fieldName)
		}
	}
	return fields
}

func findAggregatesFromServices(file *protogen.File) []*AggregateInfo {
	// Extract aggregate name from service
	aggregateName := ""
	for _, svc := range file.Services {
		name := string(svc.Desc.Name())
		if strings.HasSuffix(name, "CommandService") {
			aggregateName = strings.TrimSuffix(name, "CommandService")
			break
		}
	}

	if aggregateName == "" {
		return nil
	}

	// Create a synthetic aggregate info
	return []*AggregateInfo{
		{
			Message:     nil,
			MessageName: aggregateName,
			TypeName:    aggregateName,
			IDField:     strings.ToLower(aggregateName) + "_id",
			IDFieldGo:   aggregateName + "Id",
		},
	}
}

// Helper functions

func extractMethodName(commandName string) string {
	return strings.TrimSuffix(commandName, "Command")
}

func toGoName(protoName string) string {
	// Convert snake_case to CamelCase
	parts := strings.Split(protoName, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[0:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func hasField(msg *protogen.Message, fieldName string) bool {
	if msg == nil {
		return false
	}
	for _, field := range msg.Fields {
		if string(field.Desc.Name()) == fieldName {
			return true
		}
	}
	return false
}

func getFieldType(msg *protogen.Message, fieldName string) string {
	if msg == nil {
		return ""
	}
	for _, field := range msg.Fields {
		if string(field.Desc.Name()) == fieldName {
			if field.Enum != nil {
				return string(field.Enum.Desc.Name())
			}
		}
	}
	return ""
}

func inferEventName(commandName string) string {
	// OpenAccountCommand -> AccountOpenedEvent
	method := extractMethodName(commandName)

	// Convert verb to past tense (simple heuristic)
	if strings.HasPrefix(method, "Open") {
		return strings.TrimPrefix(method, "Open") + "OpenedEvent"
	}
	if strings.HasPrefix(method, "Close") {
		return strings.TrimPrefix(method, "Close") + "ClosedEvent"
	}
	if strings.HasPrefix(method, "Create") {
		return strings.TrimPrefix(method, "Create") + "CreatedEvent"
	}
	if strings.HasPrefix(method, "Update") {
		return strings.TrimPrefix(method, "Update") + "UpdatedEvent"
	}
	if strings.HasPrefix(method, "Delete") {
		return strings.TrimPrefix(method, "Delete") + "DeletedEvent"
	}
	if strings.HasPrefix(method, "Deposit") {
		return "MoneyDepositedEvent"
	}
	if strings.HasPrefix(method, "Withdraw") {
		return "MoneyWithdrawnEvent"
	}

	return method + "Event"
}
