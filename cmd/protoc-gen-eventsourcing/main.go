// protoc-gen-eventsourcing generates event sourcing boilerplate from proto files.
//
// This plugin generates files with the .es.pb.go extension to clearly indicate
// they are generated by the eventsourcing plugin (similar to how gRPC uses _grpc.pb.go).
//
// Generated files:
//   - *_aggregate.es.pb.go - Aggregate root structs and event applier interfaces
//   - *_sdk.es.pb.go - Type-safe SDK clients for commands and queries
//   - *_client.es.pb.go - Low-level client implementations
//   - *_handler.es.pb.go - Handler interfaces for server implementations
//   - *_server.es.pb.go - Server-side routing and request handling
//
// Configuration via Proto Options:
//
// The plugin uses custom proto options (defined in eventsourcing/options.proto):
//
//	Service level (required):
//	 - option (eventsourcing.service) = {
//	     aggregate_name: "Account"
//	     aggregate_root_message: "Account"
//	   }
//
//	Aggregate root (required):
//	 - option (eventsourcing.aggregate_root) = {id_field: "account_id"}
//
//	Events (required):
//	 - option (eventsourcing.event) = {aggregate_name: "Account"}
//
//	Commands: NO OPTIONS - inherit from service
//
// Developer responsibilities:
//   - Implement ApplyEvent methods for state updates
//   - Handle unique constraints in command handlers
//   - Manage field mapping in ApplyEvent code
package main

import (
	"flag"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	eventsourcing "github.com/plaenen/eventstore/pkg/eventsourcing"
)

var version = "0.0.8"

func main() {
	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			generateFile(gen, f)
		}

		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	// Check if there are any aggregates or events to generate
	aggregates := findAggregates(file)
	hasEvents := false
	for _, agg := range aggregates {
		events := findEventsForAggregate(gen, agg.TypeName)
		if len(events) > 0 {
			hasEvents = true
			break
		}
	}

	// Find services for later use
	services := findServices(file)

	// Skip files that don't have anything to generate
	if len(aggregates) == 0 && len(services) == 0 && !hasEvents {
		return
	}

	// Generate aggregate file only if there are aggregates or events
	if len(aggregates) > 0 || hasEvents {
		aggregateFilename := file.GeneratedFilenamePrefix + "_aggregate.es.pb.go"
		g := gen.NewGeneratedFile(aggregateFilename, file.GoImportPath)

		generateHeader(g, file)
		generateAggregates(g, file)
		generateCommandHandlers(g, file)
		generateEventAppliers(g, file, gen)
		generateRepository(g, file, gen)
		generateProjectionSDK(g, file, gen)
	}

	// Generate service-related files if there are commands or queries
	if len(services) > 0 {
		// Only generate client/SDK files if there are matching aggregates
		if hasServiceContent(aggregates, services) {
			generateSDKClient(gen, file, aggregates, services)
			generateUnifiedSDK(gen, file, aggregates, services)
		}
		// Always generate server and handler files if services have methods
		if hasServiceMethods(services) {
			generateServerService(gen, file, aggregates, services)
			generateHandlerInterfaces(gen, file, aggregates, services)
		}
	}
}

func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P("// version: ", version)
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"fmt"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/domain"`)
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(`	"github.com/plaenen/eventstore/pkg/store"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()
}

func generateAggregates(g *protogen.GeneratedFile, file *protogen.File) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		aggregateType := agg.TypeName + "Aggregate"

		g.P("// ", aggregateType, " is the aggregate root for ", agg.TypeName, " domain")
		g.P("// It embeds the proto-defined ", agg.MessageName, " for state management")
		g.P("type ", aggregateType, " struct {")
		g.P("	domain.AggregateRoot")
		g.P("	*", agg.MessageName)
		g.P("	applier ", agg.TypeName, "EventApplier  // Injected dependency for event application")
		g.P("}")
		g.P()

		// Constructor
		g.P("// New", agg.TypeName, " creates a new ", aggregateType, " instance")
		g.P("// The applier parameter defines how events modify aggregate state")
		g.P("// Implement ", agg.TypeName, "EventApplier in your domain layer")
		g.P("func New", agg.TypeName, "(id string, applier ", agg.TypeName, "EventApplier) *", aggregateType, " {")
		g.P("	return &", aggregateType, "{")
		g.P("		AggregateRoot: domain.NewAggregateRoot(id, \"", agg.TypeName, "\"),")
		g.P("		", agg.MessageName, ": &", agg.MessageName, "{},")
		g.P("		applier:       applier,")
		g.P("	}")
		g.P("}")
		g.P()

		// Snapshot support
		g.P("// MarshalSnapshot serializes the aggregate state for snapshots")
		g.P("func (a *", aggregateType, ") MarshalSnapshot() ([]byte, error) {")
		g.P("	return proto.Marshal(a.", agg.MessageName, ")")
		g.P("}")
		g.P()

		g.P("// UnmarshalSnapshot deserializes the aggregate state from snapshots")
		g.P("func (a *", aggregateType, ") UnmarshalSnapshot(data []byte) error {")
		g.P("	a.", agg.MessageName, " = &", agg.MessageName, "{}")
		g.P("	if err := proto.Unmarshal(data, a.", agg.MessageName, "); err != nil {")
		g.P("		return err")
		g.P("	}")
		g.P()
		g.P("	// UPCAST HOOK: If aggregate implements SnapshotUpcaster, upgrade old snapshots")
		g.P("	if upcaster, ok := interface{}(a).(domain.SnapshotUpcaster); ok {")
		g.P("		a.", agg.MessageName, " = upcaster.UpcastSnapshot(a.", agg.MessageName, ").(*", agg.MessageName, ")")
		g.P("	}")
		g.P()
		g.P("	return nil")
		g.P("}")
		g.P()

		// Helper to get ID from aggregate
		g.P("// ID returns the aggregate ID")
		g.P("func (a *", aggregateType, ") ID() string {")
		g.P("	return a.", agg.IDFieldGo)
		g.P("}")
		g.P()

		// Helper to get Type
		g.P("// Type returns the aggregate type name")
		g.P("func (a *", aggregateType, ") Type() string {")
		g.P("	return \"", agg.TypeName, "\"")
		g.P("}")
		g.P()
	}
}

func generateCommandHandlers(g *protogen.GeneratedFile, file *protogen.File) {
	// Command handlers are now fully implemented by developers
	// No code generation needed - developers use aggregate.ApplyChange() directly
	// This function is kept for backward compatibility but generates nothing
}

func generateEventAppliers(g *protogen.GeneratedFile, file *protogen.File, gen *protogen.Plugin) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		aggregateType := agg.TypeName + "Aggregate"
		events := findEventsForAggregate(gen, agg.TypeName)

		if len(events) == 0 {
			continue
		}

		// Generate the ApplyEvent dispatcher (delegates to injected applier)
		g.P("// ApplyEvent applies an event to the ", agg.TypeName, " aggregate")
		g.P("// This method delegates to the injected applier implementation")
		g.P("func (a *", aggregateType, ") ApplyEvent(event proto.Message) error {")
		g.P("	// UPCAST HOOK: If aggregate implements EventUpcaster, upgrade old events")
		g.P("	if upcaster, ok := interface{}(a).(domain.EventUpcaster); ok {")
		g.P("		event = upcaster.UpcastEvent(event)")
		g.P("	}")
		g.P()
		g.P("	switch e := event.(type) {")

		for _, evt := range events {
			methodName := "Apply" + evt.MessageName
			g.P("	case *", evt.MessageName, ":")
			g.P("		return a.applier.", methodName, "(a, e)  // Delegate to injected applier")
		}

		g.P("	default:")
		g.P("		return fmt.Errorf(\"unknown event type: %T\", event)")
		g.P("	}")
		g.P("}")
		g.P()

		g.P("// ============================================================================")
		g.P("// Event Applier Interface")
		g.P("// ============================================================================")
		g.P("// The aggregate needs applier methods to handle events.")
		g.P("// Implement these methods in your domain layer outside the pb/ directory.")
		g.P()

		g.P("// ", agg.TypeName, "EventApplier defines methods for applying events to ", agg.TypeName)
		g.P("// Implement this interface in your domain layer (outside pb/ directory)")
		g.P("type ", agg.TypeName, "EventApplier interface {")

		// Generate interface method signatures with aggregate parameter
		for _, evt := range events {
			methodName := "Apply" + evt.MessageName
			g.P("	// ", methodName, " applies the ", evt.MessageName, " to the aggregate state")
			g.P("	", methodName, "(agg *", aggregateType, ", e *", evt.MessageName, ") error")
		}

		g.P("}")
		g.P()

		g.P("// ============================================================================")
		g.P("// Implementing Event Appliers (Recommended Pattern)")
		g.P("// ============================================================================")
		g.P("// Create your applier implementation in your domain layer, e.g.:")
		g.P("//")
		g.P("// // In bankaccount/domain/account_appliers.go")
		g.P("// type AccountAppliers struct{}")
		g.P("//")
		for _, evt := range events {
			methodName := "Apply" + evt.MessageName
			g.P("// func (ap *AccountAppliers) ", methodName, "(agg *accountv1.", aggregateType, ", e *accountv1.", evt.MessageName, ") error {")
			g.P("//     // Update aggregate state")
			g.P("//     agg.", agg.IDFieldGo, " = e.", agg.IDFieldGo)
			g.P("//     return nil")
			g.P("// }")
			g.P("//")
		}
		g.P("// Then inject when creating aggregates:")
		g.P("//   applier := &domain.AccountAppliers{}")
		g.P("//   agg := accountv1.New", agg.TypeName, "(id, applier)")
		g.P("// ============================================================================")
		g.P()

		// Add optional upcaster interfaces documentation
		g.P("// ============================================================================")
		g.P("// OPTIONAL: Event and Snapshot Upcasting")
		g.P("// ============================================================================")
		g.P("// The aggregate can optionally implement these interfaces to handle event/snapshot evolution:")
		g.P("//")
		g.P("// type EventUpcaster interface {")
		g.P("//     UpcastEvent(event proto.Message) proto.Message")
		g.P("// }")
		g.P("//")
		g.P("// type SnapshotUpcaster interface {")
		g.P("//     UpcastSnapshot(state proto.Message) proto.Message")
		g.P("// }")
		g.P("//")
		g.P("// Example:")
		g.P("//")
		g.P("// func (a *", aggregateType, ") UpcastEvent(event proto.Message) proto.Message {")
		g.P("//     switch old := event.(type) {")
		g.P("//     case *EventV1:")
		g.P("//         return &EventV2{...}  // Convert old version to new")
		g.P("//     }")
		g.P("//     return event  // Already current version")
		g.P("// }")
		g.P()
		g.P("// See: docs/aggregate_upcasting_design.md")
		g.P("// ============================================================================")
		g.P()

		// Generate type-safe Apply{Event} helper methods with functional options
		g.P("// ============================================================================")
		g.P("// Type-Safe Event Application Helpers")
		g.P("// ============================================================================")
		g.P("// These methods provide a type-safe API for applying events with optional")
		g.P("// metadata and unique constraints. They eliminate error-prone string event types.")
		g.P()

		// Generate option types
		g.P("// ApplyEventOption configures event application with metadata and constraints")
		g.P("type ApplyEventOption func(*ApplyEventOptions)")
		g.P()

		g.P("// ApplyEventOptions holds configuration for event application")
		g.P("type ApplyEventOptions struct {")
		g.P("	Metadata    domain.EventMetadata")
		g.P("	Constraints []domain.UniqueConstraint")
		g.P("}")
		g.P()

		g.P("// WithMetadata sets the event metadata")
		g.P("func WithMetadata(metadata domain.EventMetadata) ApplyEventOption {")
		g.P("	return func(o *ApplyEventOptions) {")
		g.P("		o.Metadata = metadata")
		g.P("	}")
		g.P("}")
		g.P()

		g.P("// WithUniqueConstraints adds unique constraints to the event")
		g.P("func WithUniqueConstraints(constraints ...domain.UniqueConstraint) ApplyEventOption {")
		g.P("	return func(o *ApplyEventOptions) {")
		g.P("		o.Constraints = constraints")
		g.P("	}")
		g.P("}")
		g.P()

		// Generate type-safe Apply methods for each event
		for _, evt := range events {
			methodName := "Apply" + evt.MessageName
			fullEventType := string(file.GoPackageName) + "." + evt.MessageName

			g.P("// ", methodName, " applies the ", evt.MessageName, " with type safety and optional configuration")
			g.P("// This eliminates the need to manually specify event type strings")
			g.P("func (a *", aggregateType, ") ", methodName, "(event *", evt.MessageName, ", opts ...ApplyEventOption) error {")
			g.P("	options := &ApplyEventOptions{}")
			g.P("	for _, opt := range opts {")
			g.P("		opt(options)")
			g.P("	}")
			g.P()
			g.P("	if len(options.Constraints) > 0 {")
			g.P("		return a.AggregateRoot.ApplyChangeWithConstraints(")
			g.P("			event,")
			g.P(`			"`, fullEventType, `",`)
			g.P("			options.Metadata,")
			g.P("			options.Constraints,")
			g.P("		)")
			g.P("	}")
			g.P()
			g.P("	return a.AggregateRoot.ApplyChange(")
			g.P("		event,")
			g.P(`		"`, fullEventType, `",`)
			g.P("		options.Metadata,")
			g.P("	)")
			g.P("}")
			g.P()
		}

		g.P("// ============================================================================")
		g.P()
	}
}

func generateRepository(g *protogen.GeneratedFile, file *protogen.File, gen *protogen.Plugin) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		aggregateType := agg.TypeName + "Aggregate"
		repoName := agg.TypeName + "Repository"

		g.P("// ", repoName, " provides persistence for ", agg.TypeName)
		g.P("type ", repoName, " struct {")
		g.P("	*store.BaseRepository[*", aggregateType, "]")
		g.P("}")
		g.P()

		g.P("// New", repoName, " creates a new repository")
		g.P("// factory: function to create new aggregate instances (should inject appliers)")
		g.P("func New", repoName, "(eventStore store.EventStore, factory func(string) *", aggregateType, ") *", repoName, " {")
		g.P("	return &", repoName, "{")
		g.P("		BaseRepository: store.NewRepository[*", aggregateType, "](")
		g.P("			eventStore,")
		g.P(`			"`, agg.TypeName, `",`)
		g.P("			factory,")
		g.P("			func(agg *", aggregateType, ", event *domain.Event) error {")
		g.P("				// Deserialize and apply event")
		g.P("				msg, err := deserializeEvent", agg.TypeName, "(event)")
		g.P("				if err != nil {")
		g.P("					return err")
		g.P("				}")
		g.P("				return agg.ApplyEvent(msg)")
		g.P("			},")
		g.P("		),")
		g.P("	}")
		g.P("}")
		g.P()

		// Deserializer helper
		events := findEventsForAggregate(gen, agg.TypeName)

		g.P("func deserializeEvent", agg.TypeName, "(event *domain.Event) (proto.Message, error) {")
		g.P("	switch event.EventType {")

		for _, evt := range events {
			fullName := string(file.GoPackageName) + "." + evt.MessageName
			g.P("	case \"", fullName, "\":")
			g.P("		msg := &", evt.MessageName, "{}")
			g.P("		if err := proto.Unmarshal(event.Data, msg); err != nil {")
			g.P("			return nil, err")
			g.P("		}")
			g.P("		return msg, nil")
		}

		g.P("	default:")
		g.P("		return nil, fmt.Errorf(\"unknown event type: %s\", event.EventType)")
		g.P("	}")
		g.P("}")
		g.P()
	}
}

// Helper types

type AggregateInfo struct {
	Message     *protogen.Message
	MessageName string
	TypeName    string
	IDField     string
	IDFieldGo   string
}

type CommandInfo struct {
	MessageName   string
	MethodName    string
	AggregateName string
}

type EventInfo struct {
	MessageName   string
	AggregateName string
}

// Helper functions for reading new proto options

func getServiceOptions(svc *protogen.Service) *eventsourcing.ServiceOptions {
	if proto.HasExtension(svc.Desc.Options(), eventsourcing.E_Service) {
		return proto.GetExtension(
			svc.Desc.Options(),
			eventsourcing.E_Service,
		).(*eventsourcing.ServiceOptions)
	}
	return nil
}

func getAggregateRootOptions(msg *protogen.Message) *eventsourcing.AggregateRootOptions {
	if proto.HasExtension(msg.Desc.Options(), eventsourcing.E_AggregateRoot) {
		return proto.GetExtension(
			msg.Desc.Options(),
			eventsourcing.E_AggregateRoot,
		).(*eventsourcing.AggregateRootOptions)
	}
	return nil
}

func getEventOptions(msg *protogen.Message) *eventsourcing.EventOptions {
	if proto.HasExtension(msg.Desc.Options(), eventsourcing.E_Event) {
		return proto.GetExtension(
			msg.Desc.Options(),
			eventsourcing.E_Event,
		).(*eventsourcing.EventOptions)
	}
	return nil
}

func findAggregates(file *protogen.File) []*AggregateInfo {
	var aggregates []*AggregateInfo

	// Find all messages with aggregate_root option
	for _, msg := range file.Messages {
		opts := getAggregateRootOptions(msg)
		if opts == nil {
			continue // Not an aggregate root
		}

		messageName := string(msg.Desc.Name())

		// Get type name (defaults to message name if not specified)
		typeName := opts.GetTypeName()
		if typeName == "" {
			typeName = messageName
		}

		// Get ID field (required)
		idField := opts.GetIdField()
		if idField == "" {
			// ERROR: id_field is required
			continue
		}

		// Find the Go field name for the ID field
		idFieldGo := ""
		for _, field := range msg.Fields {
			if string(field.Desc.Name()) == idField {
				idFieldGo = field.GoName
				break
			}
		}

		if idFieldGo == "" {
			// ERROR: id_field not found in message
			continue
		}

		aggregates = append(aggregates, &AggregateInfo{
			Message:     msg,
			MessageName: messageName,
			TypeName:    typeName,
			IDField:     idField,
			IDFieldGo:   idFieldGo,
		})
	}

	return aggregates
}

func findCommands(file *protogen.File) []*CommandInfo {
	var commands []*CommandInfo

	// Find aggregate name from service options
	aggregateName := ""
	for _, svc := range file.Services {
		if opts := getServiceOptions(svc); opts != nil {
			aggregateName = opts.GetAggregateName()
			break
		}
	}

	// If no service options found, fall back to naming convention
	if aggregateName == "" {
		for _, svc := range file.Services {
			name := string(svc.Desc.Name())
			if strings.HasSuffix(name, "CommandService") {
				aggregateName = strings.TrimSuffix(name, "CommandService")
				break
			}
		}
	}

	for _, msg := range file.Messages {
		if !strings.HasSuffix(string(msg.Desc.Name()), "Command") {
			continue
		}

		commands = append(commands, &CommandInfo{
			MessageName:   string(msg.Desc.Name()),
			MethodName:    extractMethodName(string(msg.Desc.Name())),
			AggregateName: aggregateName,
		})
	}

	return commands
}

func findEventsForAggregate(gen *protogen.Plugin, aggregateName string) []*EventInfo {
	var events []*EventInfo

	// Search across ALL files in the plugin (supports events in separate proto files)
	for _, file := range gen.Files {
		for _, msg := range file.Messages {
			if !strings.HasSuffix(string(msg.Desc.Name()), "Event") {
				continue
			}

			// Check for event option (required in new design)
			opts := getEventOptions(msg)
			if opts == nil {
				continue // Skip events without explicit event option
			}

			// Only include events that belong to this aggregate
			if opts.GetAggregateName() != aggregateName {
				continue
			}

			events = append(events, &EventInfo{
				MessageName:   string(msg.Desc.Name()),
				AggregateName: aggregateName,
			})
		}
	}

	return events
}

// Helper functions

func extractMethodName(commandName string) string {
	return strings.TrimSuffix(commandName, "Command")
}

func toGoName(protoName string) string {
	// Convert snake_case to CamelCase
	parts := strings.Split(protoName, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[0:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func hasField(msg *protogen.Message, fieldName string) bool {
	if msg == nil {
		return false
	}
	for _, field := range msg.Fields {
		if string(field.Desc.Name()) == fieldName {
			return true
		}
	}
	return false
}

func getFieldType(msg *protogen.Message, fieldName string) string {
	if msg == nil {
		return ""
	}
	for _, field := range msg.Fields {
		if string(field.Desc.Name()) == fieldName {
			if field.Enum != nil {
				return string(field.Enum.Desc.Name())
			}
		}
	}
	return ""
}

func inferEventName(commandName string) string {
	// OpenAccountCommand -> AccountOpenedEvent
	method := extractMethodName(commandName)

	// Convert verb to past tense (simple heuristic)
	if strings.HasPrefix(method, "Open") {
		return strings.TrimPrefix(method, "Open") + "OpenedEvent"
	}
	if strings.HasPrefix(method, "Close") {
		return strings.TrimPrefix(method, "Close") + "ClosedEvent"
	}
	if strings.HasPrefix(method, "Create") {
		return strings.TrimPrefix(method, "Create") + "CreatedEvent"
	}
	if strings.HasPrefix(method, "Update") {
		return strings.TrimPrefix(method, "Update") + "UpdatedEvent"
	}
	if strings.HasPrefix(method, "Delete") {
		return strings.TrimPrefix(method, "Delete") + "DeletedEvent"
	}
	if strings.HasPrefix(method, "Deposit") {
		return "MoneyDepositedEvent"
	}
	if strings.HasPrefix(method, "Withdraw") {
		return "MoneyWithdrawnEvent"
	}

	return method + "Event"
}

// ServiceInfo holds information about gRPC services
type ServiceInfo struct {
	Name          string
	Commands      []*protogen.Method
	Queries       []*protogen.Method
	Service       *protogen.Service
	AggregateName string
}

// hasServiceContent checks if services have any content to generate for client/SDK files
// Returns true if there are aggregates matching the services and those services have methods
func hasServiceContent(aggregates []*AggregateInfo, services []*ServiceInfo) bool {
	if len(aggregates) == 0 || len(services) == 0 {
		return false
	}

	// Check if any service has methods that match an aggregate
	for _, svc := range services {
		// Check if this service has any commands or queries
		if len(svc.Commands) == 0 && len(svc.Queries) == 0 {
			continue
		}

		// Check if there's an aggregate that matches this service
		for _, agg := range aggregates {
			if agg.TypeName == svc.AggregateName {
				return true
			}
		}
	}

	return false
}

// hasServiceMethods checks if any service has commands or queries to generate
// Returns true if there are services with at least one command or query
func hasServiceMethods(services []*ServiceInfo) bool {
	for _, svc := range services {
		if len(svc.Commands) > 0 || len(svc.Queries) > 0 {
			return true
		}
	}
	return false
}

// findServices finds all command and query services in the proto file
func findServices(file *protogen.File) []*ServiceInfo {
	var services []*ServiceInfo

	for _, svc := range file.Services {
		name := string(svc.Desc.Name())

		// Determine aggregate name and service type
		var aggregateName string
		var serviceType string

		if strings.HasSuffix(name, "CommandService") {
			aggregateName = strings.TrimSuffix(name, "CommandService")
			serviceType = "command"
		} else if strings.HasSuffix(name, "QueryService") {
			aggregateName = strings.TrimSuffix(name, "QueryService")
			serviceType = "query"
		} else {
			continue // Skip other services
		}

		info := &ServiceInfo{
			Name:          name,
			Service:       svc,
			AggregateName: aggregateName,
			Commands:      make([]*protogen.Method, 0),
			Queries:       make([]*protogen.Method, 0),
		}

		// Categorize methods
		for _, method := range svc.Methods {
			if serviceType == "command" {
				info.Commands = append(info.Commands, method)
			} else if serviceType == "query" {
				info.Queries = append(info.Queries, method)
			}
		}

		services = append(services, info)
	}

	return services
}

// generateSDKClient generates a type-safe SDK client for commands and queries using Transport
func generateSDKClient(gen *protogen.Plugin, file *protogen.File, aggregates []*AggregateInfo, services []*ServiceInfo) {
	clientFilename := file.GeneratedFilenamePrefix + "_client.es.pb.go"
	g := gen.NewGeneratedFile(clientFilename, file.GoImportPath)

	// Header
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P("// version: ", version)
	g.P("// Client SDK for ", file.Desc.Name())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(")")
	g.P()

	// Generate aggregate-specific client for each aggregate
	for _, agg := range aggregates {
		clientName := agg.TypeName + "Client"

		g.P("// ", clientName, " provides type-safe methods for ", agg.TypeName, " commands and queries")
		g.P("type ", clientName, " struct {")
		g.P("	transport eventsourcing.Transport")
		g.P("}")
		g.P()

		g.P("// New", clientName, " creates a new type-safe client for ", agg.TypeName)
		g.P("func New", clientName, "(transport eventsourcing.Transport) *", clientName, " {")
		g.P("	return &", clientName, "{transport: transport}")
		g.P("}")
		g.P()

		// Find services for this aggregate
		for _, svc := range services {
			if svc.AggregateName != agg.TypeName {
				continue
			}

			// Generate command methods
			for _, method := range svc.Commands {
				methodName := method.GoName
				inputType := g.QualifiedGoIdent(method.Input.GoIdent)
				outputType := g.QualifiedGoIdent(method.Output.GoIdent)
				subject := string(file.Desc.Package()) + "." + svc.Name + "." + methodName

				g.P("// ", methodName, " sends a ", methodName, " command and returns the response")
				g.P("func (c *", clientName, ") ", methodName, "(ctx context.Context, cmd *", inputType, ") (*", outputType, ", *eventsourcing.AppError) {")
				g.P("	// Send request via transport")
				g.P(`	resp, err := c.transport.Request(ctx, "`, subject, `", cmd)`)
				g.P("	if err != nil {")
				g.P("		return nil, &eventsourcing.AppError{")
				g.P(`			Code:    "TRANSPORT_ERROR",`)
				g.P("			Message: err.Error(),")
				g.P("		}")
				g.P("	}")
				g.P()
				g.P("	// Check if request succeeded")
				g.P("	if !resp.Success {")
				g.P("		return nil, resp.GetError()")
				g.P("	}")
				g.P()
				g.P("	// Unpack response data")
				g.P("	result := &", outputType, "{}")
				g.P("	if err := resp.UnpackData(result); err != nil {")
				g.P("		return nil, &eventsourcing.AppError{")
				g.P(`			Code:    "INVALID_RESPONSE",`)
				g.P("			Message: err.Error(),")
				g.P("		}")
				g.P("	}")
				g.P()
				g.P("	return result, nil")
				g.P("}")
				g.P()
			}

			// Generate query methods
			for _, method := range svc.Queries {
				methodName := method.GoName
				inputType := g.QualifiedGoIdent(method.Input.GoIdent)
				outputType := g.QualifiedGoIdent(method.Output.GoIdent)
				subject := string(file.Desc.Package()) + "." + svc.Name + "." + methodName

				g.P("// ", methodName, " executes a ", methodName, " query and returns the result")
				g.P("func (c *", clientName, ") ", methodName, "(ctx context.Context, query *", inputType, ") (*", outputType, ", *eventsourcing.AppError) {")
				g.P("	// Send request via transport")
				g.P(`	resp, err := c.transport.Request(ctx, "`, subject, `", query)`)
				g.P("	if err != nil {")
				g.P("		return nil, &eventsourcing.AppError{")
				g.P(`			Code:    "TRANSPORT_ERROR",`)
				g.P("			Message: err.Error(),")
				g.P("		}")
				g.P("	}")
				g.P()
				g.P("	// Check if request succeeded")
				g.P("	if !resp.Success {")
				g.P("		return nil, resp.GetError()")
				g.P("	}")
				g.P()
				g.P("	// Unpack response data")
				g.P("	result := &", outputType, "{}")
				g.P("	if err := resp.UnpackData(result); err != nil {")
				g.P("		return nil, &eventsourcing.AppError{")
				g.P(`			Code:    "INVALID_RESPONSE",`)
				g.P("			Message: err.Error(),")
				g.P("		}")
				g.P("	}")
				g.P()
				g.P("	return result, nil")
				g.P("}")
				g.P()
			}
		}
	}
}

// findIDField finds the ID field in a message (looks for fields ending with _id)
func findIDField(msg *protogen.Message) string {
	for _, field := range msg.Fields {
		fieldName := string(field.Desc.Name())
		if strings.HasSuffix(fieldName, "_id") {
			return field.GoName
		}
	}
	// Fallback to first string field
	for _, field := range msg.Fields {
		if field.Desc.Kind().String() == "string" {
			return field.GoName
		}
	}
	return "Id"
}

// generateHandlerInterfaces generates handler interfaces for developers to implement
func generateHandlerInterfaces(gen *protogen.Plugin, file *protogen.File, aggregates []*AggregateInfo, services []*ServiceInfo) {
	handlerFilename := file.GeneratedFilenamePrefix + "_handler.es.pb.go"
	g := gen.NewGeneratedFile(handlerFilename, file.GoImportPath)

	// Header
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P("// version: ", version)
	g.P("// Handler interfaces for ", file.Desc.Name())
	g.P("// Developers implement these interfaces to handle commands and queries")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(")")
	g.P()

	// Generate handler interface for each service
	for _, svc := range services {
		handlerName := svc.Name + "Handler"

		g.P("// ", handlerName, " is the interface developers implement to handle ", svc.Name, " requests")
		g.P("type ", handlerName, " interface {")

		// Generate method signatures for commands
		for _, method := range svc.Commands {
			methodName := method.GoName
			inputType := g.QualifiedGoIdent(method.Input.GoIdent)
			outputType := g.QualifiedGoIdent(method.Output.GoIdent)

			g.P("	// ", methodName, " handles the ", methodName, " command")
			g.P("	", methodName, "(ctx context.Context, cmd *", inputType, ") (*", outputType, ", *eventsourcing.AppError)")
		}

		// Generate method signatures for queries
		for _, method := range svc.Queries {
			methodName := method.GoName
			inputType := g.QualifiedGoIdent(method.Input.GoIdent)
			outputType := g.QualifiedGoIdent(method.Output.GoIdent)

			g.P("	// ", methodName, " handles the ", methodName, " query")
			g.P("	", methodName, "(ctx context.Context, query *", inputType, ") (*", outputType, ", *eventsourcing.AppError)")
		}

		g.P("}")
		g.P()
	}
}

// generateServerService generates server-side service that routes requests to handlers
func generateServerService(gen *protogen.Plugin, file *protogen.File, aggregates []*AggregateInfo, services []*ServiceInfo) {
	serverFilename := file.GeneratedFilenamePrefix + "_server.es.pb.go"
	g := gen.NewGeneratedFile(serverFilename, file.GoImportPath)

	// Header
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P("// version: ", version)
	g.P("// Server service for ", file.Desc.Name())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"fmt"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()

	// Generate server for each service
	for _, svc := range services {
		serverName := svc.Name + "Server"
		handlerName := svc.Name + "Handler"

		// Server struct
		g.P("// ", serverName, " handles ", svc.Name, " requests by routing them to the handler")
		g.P("type ", serverName, " struct {")
		g.P("	server  eventsourcing.Server")
		g.P("	handler ", handlerName)
		g.P("}")
		g.P()

		// Constructor
		g.P("// New", serverName, " creates a new server for ", svc.Name)
		g.P("func New", serverName, "(server eventsourcing.Server, handler ", handlerName, ") *", serverName, " {")
		g.P("	return &", serverName, "{")
		g.P("		server:  server,")
		g.P("		handler: handler,")
		g.P("	}")
		g.P("}")
		g.P()

		// Start method
		g.P("// Start registers all handlers and starts the server")
		g.P("func (s *", serverName, ") Start(ctx context.Context) error {")

		// Register handlers for commands
		for _, method := range svc.Commands {
			methodName := method.GoName
			subject := string(file.Desc.Package()) + "." + svc.Name + "." + methodName

			g.P("	// Register ", methodName, " handler")
			g.P(`	if err := s.server.RegisterHandler("`, subject, `", s.handle`, methodName, `); err != nil {`)
			g.P("		return fmt.Errorf(\"failed to register ", methodName, " handler: %w\", err)")
			g.P("	}")
		}

		// Register handlers for queries
		for _, method := range svc.Queries {
			methodName := method.GoName
			subject := string(file.Desc.Package()) + "." + svc.Name + "." + methodName

			g.P("	// Register ", methodName, " handler")
			g.P(`	if err := s.server.RegisterHandler("`, subject, `", s.handle`, methodName, `); err != nil {`)
			g.P("		return fmt.Errorf(\"failed to register ", methodName, " handler: %w\", err)")
			g.P("	}")
		}

		g.P()
		g.P("	return s.server.Start(ctx)")
		g.P("}")
		g.P()

		// Generate handler wrapper methods for commands
		for _, method := range svc.Commands {
			methodName := method.GoName
			inputType := g.QualifiedGoIdent(method.Input.GoIdent)

			g.P("func (s *", serverName, ") handle", methodName, "(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {")
			g.P("	cmd := request.(*", inputType, ")")
			g.P("	result, appErr := s.handler.", methodName, "(ctx, cmd)")
			g.P("	if appErr != nil {")
			g.P("		return &eventsourcing.Response{")
			g.P("			Success: false,")
			g.P("			Error:   appErr,")
			g.P("		}, nil")
			g.P("	}")
			g.P("	return eventsourcing.NewSuccessResponse(result)")
			g.P("}")
			g.P()
		}

		// Generate handler wrapper methods for queries
		for _, method := range svc.Queries {
			methodName := method.GoName
			inputType := g.QualifiedGoIdent(method.Input.GoIdent)

			g.P("func (s *", serverName, ") handle", methodName, "(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {")
			g.P("	query := request.(*", inputType, ")")
			g.P("	result, appErr := s.handler.", methodName, "(ctx, query)")
			g.P("	if appErr != nil {")
			g.P("		return &eventsourcing.Response{")
			g.P("			Success: false,")
			g.P("			Error:   appErr,")
			g.P("		}, nil")
			g.P("	}")
			g.P("	return eventsourcing.NewSuccessResponse(result)")
			g.P("}")
			g.P()
		}

		// Close method
		g.P("// Close stops the server")
		g.P("func (s *", serverName, ") Close() error {")
		g.P("	return s.server.Close()")
		g.P("}")
		g.P()
	}
}

// generateUnifiedSDK generates a unified SDK wrapper that combines client functionality
func generateUnifiedSDK(gen *protogen.Plugin, file *protogen.File, aggregates []*AggregateInfo, services []*ServiceInfo) {
	sdkFilename := file.GeneratedFilenamePrefix + "_sdk.es.pb.go"
	g := gen.NewGeneratedFile(sdkFilename, file.GoImportPath)

	// Header
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P("// version: ", version)
	g.P("// Unified SDK for ", file.Desc.Name())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(")")
	g.P()

	// Generate SDK for each aggregate
	for _, agg := range aggregates {
		sdkName := agg.TypeName + "SDK"
		clientName := agg.TypeName + "Client"

		// SDK documentation
		g.P("// ", sdkName, " provides a unified, developer-friendly interface for the ", agg.TypeName, " service.")
		g.P("// It combines all commands and queries into a single client that only requires a transport.")
		g.P("//")
		g.P("// Example usage:")
		g.P("//")
		g.P("//	transport, _ := nats.NewTransport(&nats.TransportConfig{...})")
		g.P("//	sdk := ", file.GoPackageName, ".New", sdkName, "(transport)")
		g.P("//")
		g.P("//	// Execute commands and queries")

		// Find first command as example
		for _, svc := range services {
			if svc.AggregateName == agg.TypeName && len(svc.Commands) > 0 {
				firstCmd := svc.Commands[0]
				cmdName := firstCmd.GoName
				g.P("//	resp, err := sdk.", cmdName, "(ctx, &", file.GoPackageName, ".", firstCmd.Input.GoIdent.GoName, "{...})")
				break
			}
		}

		g.P("type ", sdkName, " struct {")
		g.P("	client *", clientName)
		g.P("}")
		g.P()

		// Constructor
		g.P("// New", sdkName, " creates a new unified SDK for the ", agg.TypeName, " service.")
		g.P("// It only requires a transport - all service clients are created automatically.")
		g.P("func New", sdkName, "(transport eventsourcing.Transport) *", sdkName, " {")
		g.P("	return &", sdkName, "{")
		g.P("		client: New", clientName, "(transport),")
		g.P("	}")
		g.P("}")
		g.P()

		// Generate wrapper methods for commands and queries
		for _, svc := range services {
			if svc.AggregateName != agg.TypeName {
				continue
			}

			// Commands
			if len(svc.Commands) > 0 {
				g.P("// Commands")
				g.P()
			}

			for _, method := range svc.Commands {
				methodName := method.GoName
				inputType := g.QualifiedGoIdent(method.Input.GoIdent)
				outputType := g.QualifiedGoIdent(method.Output.GoIdent)

				// Extract brief description from method name
				description := extractDescription(methodName)

				g.P("// ", methodName, " ", description)
				g.P("func (s *", sdkName, ") ", methodName, "(ctx context.Context, cmd *", inputType, ") (*", outputType, ", *eventsourcing.AppError) {")
				g.P("	return s.client.", methodName, "(ctx, cmd)")
				g.P("}")
				g.P()
			}

			// Queries
			if len(svc.Queries) > 0 {
				g.P("// Queries")
				g.P()
			}

			for _, method := range svc.Queries {
				methodName := method.GoName
				inputType := g.QualifiedGoIdent(method.Input.GoIdent)
				outputType := g.QualifiedGoIdent(method.Output.GoIdent)

				description := extractDescription(methodName)

				g.P("// ", methodName, " ", description)
				g.P("func (s *", sdkName, ") ", methodName, "(ctx context.Context, query *", inputType, ") (*", outputType, ", *eventsourcing.AppError) {")
				g.P("	return s.client.", methodName, "(ctx, query)")
				g.P("}")
				g.P()
			}
		}

		// Utility methods
		g.P("// Transport returns the underlying transport used by this SDK.")
		g.P("// This can be useful for cleanup or advanced use cases.")
		g.P("func (s *", sdkName, ") Transport() eventsourcing.Transport {")
		g.P("	return s.client.transport")
		g.P("}")
		g.P()

		g.P("// Close closes the underlying transport connection.")
		g.P("// This is a convenience method equivalent to calling Transport().Close()")
		g.P("func (s *", sdkName, ") Close() error {")
		g.P("	return s.client.transport.Close()")
		g.P("}")
		g.P()
	}
}

// extractDescription creates a brief description from a method name
func extractDescription(methodName string) string {
	switch {
	case strings.HasPrefix(methodName, "Get"):
		return "retrieves " + strings.ToLower(strings.TrimPrefix(methodName, "Get"))
	case strings.HasPrefix(methodName, "List"):
		return "lists " + strings.ToLower(strings.TrimPrefix(methodName, "List"))
	case strings.HasPrefix(methodName, "Create"):
		return "creates a new " + strings.ToLower(strings.TrimPrefix(methodName, "Create"))
	case strings.HasPrefix(methodName, "Update"):
		return "updates " + strings.ToLower(strings.TrimPrefix(methodName, "Update"))
	case strings.HasPrefix(methodName, "Delete"):
		return "deletes " + strings.ToLower(strings.TrimPrefix(methodName, "Delete"))
	case strings.HasPrefix(methodName, "Open"):
		return "opens " + strings.ToLower(strings.TrimPrefix(methodName, "Open"))
	case strings.HasPrefix(methodName, "Close"):
		return "closes " + strings.ToLower(strings.TrimPrefix(methodName, "Close"))
	case methodName == "Deposit":
		return "adds money to an account"
	case methodName == "Withdraw":
		return "removes money from an account"
	default:
		return "executes " + strings.ToLower(methodName)
	}
}

func generateProjectionSDK(g *protogen.GeneratedFile, file *protogen.File, gen *protogen.Plugin) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		events := findEventsForAggregate(gen, agg.TypeName)
		if len(events) == 0 {
			continue
		}

		builderType := agg.TypeName + "ProjectionBuilder"

		// Event type constants
		g.P("// Event type constants for ", agg.TypeName)
		g.P("const (")
		for _, evt := range events {
			constName := evt.MessageName + "Type"
			fullEventType := string(file.GoPackageName) + "." + evt.MessageName
			g.P("	", constName, " = \"", fullEventType, "\"")
		}
		g.P(")")
		g.P()

		// Typed event handler function types
		g.P("// Typed event handlers for ", agg.TypeName)
		for _, evt := range events {
			handlerType := evt.MessageName + "Handler"
			g.P("type ", handlerType, " func(ctx context.Context, event *", evt.MessageName, ", envelope *domain.EventEnvelope) error")
		}
		g.P()

		// Projection builder struct
		g.P("// ", builderType, " provides a fluent API for building type-safe projections")
		g.P("type ", builderType, " struct {")
		g.P("	name string")
		g.P("	handlers map[string]func(context.Context, *domain.EventEnvelope) error")
		g.P("	resetFunc func(context.Context) error")
		g.P("}")
		g.P()

		// Constructor
		g.P("// New", builderType, " creates a new projection builder")
		g.P("func New", builderType, "(name string) *", builderType, " {")
		g.P("	return &", builderType, "{")
		g.P("		name: name,")
		g.P("		handlers: make(map[string]func(context.Context, *domain.EventEnvelope) error),")
		g.P("	}")
		g.P("}")
		g.P()

		// On{Event} methods for each event type
		for _, evt := range events {
			methodName := "On" + strings.TrimSuffix(evt.MessageName, "Event")
			handlerType := evt.MessageName + "Handler"
			constName := evt.MessageName + "Type"

			g.P("// ", methodName, " registers a typed handler for ", evt.MessageName)
			g.P("func (b *", builderType, ") ", methodName, "(handler ", handlerType, ") *", builderType, " {")
			g.P("	b.handlers[", constName, "] = func(ctx context.Context, envelope *domain.EventEnvelope) error {")
			g.P("		// Deserialize event")
			g.P("		event := &", evt.MessageName, "{}")
			g.P("		if err := proto.Unmarshal(envelope.Data, event); err != nil {")
			g.P("			return fmt.Errorf(\"failed to unmarshal ", evt.MessageName, ": %w\", err)")
			g.P("		}")
			g.P("		// Call typed handler")
			g.P("		return handler(ctx, event, envelope)")
			g.P("	}")
			g.P("	return b")
			g.P("}")
			g.P()
		}

		// OnReset method
		g.P("// OnReset registers a function to reset the projection state")
		g.P("func (b *", builderType, ") OnReset(resetFunc func(context.Context) error) *", builderType, " {")
		g.P("	b.resetFunc = resetFunc")
		g.P("	return b")
		g.P("}")
		g.P()

		// Generate standalone On{Event} wrapper functions for generic projection builder
		g.P("// Standalone event handler wrappers for cross-domain projections")
		g.P("// These can be used with eventsourcing.NewProjectionBuilder()")
		g.P()
		for _, evt := range events {
			methodName := "On" + strings.TrimSuffix(evt.MessageName, "Event")
			handlerType := evt.MessageName + "Handler"
			constName := evt.MessageName + "Type"

			g.P("// ", methodName, " creates an event handler registration for ", evt.MessageName)
			g.P("// Use with eventsourcing.NewProjectionBuilder().On(", methodName, "(handler))")
			g.P("func ", methodName, "(handler ", handlerType, ") store.EventHandlerRegistration {")
			g.P("	return store.EventHandlerRegistration{")
			g.P("		EventType: ", constName, ",")
			g.P("		Handler: func(ctx context.Context, envelope *domain.EventEnvelope) error {")
			g.P("			// Deserialize event")
			g.P("			event := &", evt.MessageName, "{}")
			g.P("			if err := proto.Unmarshal(envelope.Data, event); err != nil {")
			g.P("				return fmt.Errorf(\"failed to unmarshal ", evt.MessageName, ": %w\", err)")
			g.P("			}")
			g.P("			// Call typed handler")
			g.P("			return handler(ctx, event, envelope)")
			g.P("		},")
			g.P("	}")
			g.P("}")
			g.P()
		}
		g.P()

		// Build method
		g.P("// Build creates the final Projection implementation")
		g.P("func (b *", builderType, ") Build() eventsourcing.Projection {")
		g.P("	return &", agg.TypeName, "Projection{")
		g.P("		name: b.name,")
		g.P("		handlers: b.handlers,")
		g.P("		resetFunc: b.resetFunc,")
		g.P("	}")
		g.P("}")
		g.P()

		// Projection implementation
		projectionType := agg.TypeName + "Projection"
		g.P("// ", projectionType, " implements eventsourcing.Projection with type-safe handlers")
		g.P("type ", projectionType, " struct {")
		g.P("	name string")
		g.P("	handlers map[string]func(context.Context, *domain.EventEnvelope) error")
		g.P("	resetFunc func(context.Context) error")
		g.P("}")
		g.P()

		g.P("// Name returns the projection name")
		g.P("func (p *", projectionType, ") Name() string {")
		g.P("	return p.name")
		g.P("}")
		g.P()

		g.P("// Handle dispatches events to registered typed handlers")
		g.P("func (p *", projectionType, ") Handle(ctx context.Context, envelope *domain.EventEnvelope) error {")
		g.P("	handler, exists := p.handlers[envelope.EventType]")
		g.P("	if !exists {")
		g.P("		// No handler registered for this event type - skip it")
		g.P("		return nil")
		g.P("	}")
		g.P("	return handler(ctx, envelope)")
		g.P("}")
		g.P()

		g.P("// Reset resets the projection state")
		g.P("func (p *", projectionType, ") Reset(ctx context.Context) error {")
		g.P("	if p.resetFunc == nil {")
		g.P("		return nil // No reset function registered")
		g.P("	}")
		g.P("	return p.resetFunc(ctx)")
		g.P("}")
		g.P()
	}
}
