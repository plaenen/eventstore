// protoc-gen-eventsourcing generates event sourcing boilerplate from proto files.
//
// This plugin generates:
//   - Aggregate root structs based on proto messages marked with (eventsourcing.aggregate_root)
//   - Command handler helper methods
//   - Event applier methods
//   - Type-safe repositories
//
// Configuration via Proto Options:
//
// The plugin uses custom proto options (defined in eventsourcing/options.proto):
//
//   - Message option: (eventsourcing.aggregate_root) marks a proto message as an aggregate
//   - Message option: (eventsourcing.event_options) configures event-to-state mapping
//   - Message option: (eventsourcing.aggregate_options) for commands (produces_events, constraints)
//   - Service option: (eventsourcing.aggregate_name) = "AggregateName"
package main

import (
	"flag"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	eventsourcing "github.com/plaenen/eventstore/gen/go/eventsourcing"
)

func main() {
	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			generateFile(gen, f)
		}

		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	// Check if there are any aggregates, commands, or events to generate
	aggregates := findAggregates(file)
	commands := findCommands(file)
	hasEvents := false
	for _, agg := range aggregates {
		events := findEventsForAggregate(file, agg.TypeName)
		if len(events) > 0 {
			hasEvents = true
			break
		}
	}

	// Skip files that don't have anything to generate
	if len(aggregates) == 0 && len(commands) == 0 && !hasEvents {
		return
	}

	// Generate aggregate file
	aggregateFilename := file.GeneratedFilenamePrefix + "_aggregate.pb.go"
	g := gen.NewGeneratedFile(aggregateFilename, file.GoImportPath)

	generateHeader(g, file)
	generateAggregates(g, file)
	generateCommandHandlers(g, file)
	generateEventAppliers(g, file)
	generateRepository(g, file)

	// Generate SDK client if there are commands or queries
	services := findServices(file)
	if len(services) > 0 {
		generateSDKClient(gen, file, aggregates, services)
		generateUnifiedSDK(gen, file, aggregates, services)
		generateServerService(gen, file, aggregates, services)
		generateHandlerInterfaces(gen, file, aggregates, services)
	}
}

func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"fmt"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()
}

func generateAggregates(g *protogen.GeneratedFile, file *protogen.File) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		aggregateType := agg.TypeName + "Aggregate"

		g.P("// ", aggregateType, " is the aggregate root for ", agg.TypeName, " domain")
		g.P("// It embeds the proto-defined ", agg.MessageName, " for state management")
		g.P("type ", aggregateType, " struct {")
		g.P("	eventsourcing.AggregateRoot")
		g.P("	*", agg.MessageName)
		g.P("}")
		g.P()

		// Constructor
		g.P("// New", agg.TypeName, " creates a new ", aggregateType, " instance")
		g.P("func New", agg.TypeName, "(id string) *", aggregateType, " {")
		g.P("	return &", aggregateType, "{")
		g.P("		AggregateRoot: eventsourcing.NewAggregateRoot(id, \"", agg.TypeName, "\"),")
		g.P("		", agg.MessageName, ": &", agg.MessageName, "{},")
		g.P("	}")
		g.P("}")
		g.P()

		// Snapshot support
		g.P("// MarshalSnapshot serializes the aggregate state for snapshots")
		g.P("func (a *", aggregateType, ") MarshalSnapshot() ([]byte, error) {")
		g.P("	return proto.Marshal(a.", agg.MessageName, ")")
		g.P("}")
		g.P()

		g.P("// UnmarshalSnapshot deserializes the aggregate state from snapshots")
		g.P("func (a *", aggregateType, ") UnmarshalSnapshot(data []byte) error {")
		g.P("	a.", agg.MessageName, " = &", agg.MessageName, "{}")
		g.P("	return proto.Unmarshal(data, a.", agg.MessageName, ")")
		g.P("}")
		g.P()

		// Helper to get ID from aggregate
		g.P("// ID returns the aggregate ID")
		g.P("func (a *", aggregateType, ") ID() string {")
		g.P("	return a.", agg.IDFieldGo)
		g.P("}")
		g.P()

		// Helper to get Type
		g.P("// Type returns the aggregate type name")
		g.P("func (a *", aggregateType, ") Type() string {")
		g.P("	return \"", agg.TypeName, "\"")
		g.P("}")
		g.P()
	}
}

func generateCommandHandlers(g *protogen.GeneratedFile, file *protogen.File) {
	aggregates := findAggregates(file)

	if len(aggregates) == 0 {
		return
	}

	// Find commands and their associated events
	commands := findCommands(file)

	for _, cmd := range commands {
		aggregateName := cmd.AggregateName

		// Find the aggregate
		var agg *AggregateInfo
		for _, a := range aggregates {
			if a.TypeName == aggregateName {
				agg = a
				break
			}
		}
		if agg == nil {
			continue
		}

		aggregateType := agg.TypeName + "Aggregate"

		// Generate helper methods for each event the command produces
		for _, eventName := range cmd.ProducesEvents {
			g.P("// Emit", eventName, " is a helper to emit ", eventName, " after validation")
			g.P("// Call this from your custom ", cmd.MethodName, " implementation")
			g.P("func (a *", aggregateType, ") Emit", eventName, "(event *", eventName, ", metadata eventsourcing.EventMetadata) error {")

			if len(cmd.UniqueConstraints) > 0 {
				g.P("	constraints := []eventsourcing.UniqueConstraint{")
				for _, constraint := range cmd.UniqueConstraints {
					g.P("		{")
					g.P("			IndexName: \"", constraint.IndexName, "\",")
					g.P("			Value: event.", constraint.FieldGo, ",")
					g.P("			Operation: eventsourcing.Constraint", strings.Title(strings.ToLower(constraint.Operation)), ",")
					g.P("		},")
				}
				g.P("	}")
				g.P("	return a.ApplyChangeWithConstraints(event, \"", file.GoPackageName, ".", eventName, "\", metadata, constraints)")
			} else {
				g.P("	return a.ApplyChange(event, \"", file.GoPackageName, ".", eventName, "\", metadata)")
			}

			g.P("}")
			g.P()
		}
	}
}

func generateEventAppliers(g *protogen.GeneratedFile, file *protogen.File) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		aggregateType := agg.TypeName + "Aggregate"
		events := findEventsForAggregate(file, agg.TypeName)

		if len(events) == 0 {
			continue
		}

		// Generate the ApplyEvent dispatcher (routes to specific applier methods)
		g.P("// ApplyEvent applies an event to the ", agg.TypeName, " aggregate")
		g.P("// This method routes events to their specific applier methods")
		g.P("func (a *", aggregateType, ") ApplyEvent(event proto.Message) error {")
		g.P("	switch e := event.(type) {")

		for _, evt := range events {
			methodName := "Apply" + evt.MessageName
			g.P("	case *", evt.MessageName, ":")
			g.P("		return a.", methodName, "(e)")
		}

		g.P("	default:")
		g.P("		return fmt.Errorf(\"unknown event type: %T\", event)")
		g.P("	}")
		g.P("}")
		g.P()

		g.P("// ", agg.TypeName, "EventApplier defines methods for applying events to ", agg.TypeName)
		g.P("// Developers must implement these methods to define how events change aggregate state")
		g.P("type ", agg.TypeName, "EventApplier interface {")

		// Generate interface method signatures
		for _, evt := range events {
			methodName := "Apply" + evt.MessageName
			g.P("	// ", methodName, " applies the ", evt.MessageName, " to the aggregate state")
			g.P("	", methodName, "(e *", evt.MessageName, ") error")
		}

		g.P("}")
		g.P()

		g.P("// The ", aggregateType, " must implement ", agg.TypeName, "EventApplier")
		g.P("// Developer implements these methods in a separate file (not generated)")
		g.P()
	}
}

func generateRepository(g *protogen.GeneratedFile, file *protogen.File) {
	aggregates := findAggregates(file)

	for _, agg := range aggregates {
		aggregateType := agg.TypeName + "Aggregate"
		repoName := agg.TypeName + "Repository"

		g.P("// ", repoName, " provides persistence for ", agg.TypeName)
		g.P("type ", repoName, " struct {")
		g.P("	*eventsourcing.BaseRepository[*", aggregateType, "]")
		g.P("}")
		g.P()

		g.P("// New", repoName, " creates a new repository")
		g.P("func New", repoName, "(eventStore eventsourcing.EventStore) *", repoName, " {")
		g.P("	return &", repoName, "{")
		g.P("		BaseRepository: eventsourcing.NewRepository[*", aggregateType, "](")
		g.P("			eventStore,")
		g.P(`			"`, agg.TypeName, `",`)
		g.P("			func(id string) *", aggregateType, " {")
		g.P("				return New", agg.TypeName, "(id)")
		g.P("			},")
		g.P("			func(agg *", aggregateType, ", event *eventsourcing.Event) error {")
		g.P("				// Deserialize and apply event")
		g.P("				msg, err := deserializeEvent", agg.TypeName, "(event)")
		g.P("				if err != nil {")
		g.P("					return err")
		g.P("				}")
		g.P("				return agg.ApplyEvent(msg)")
		g.P("			},")
		g.P("		),")
		g.P("	}")
		g.P("}")
		g.P()

		// Deserializer helper
		events := findEventsForAggregate(file, agg.TypeName)

		g.P("func deserializeEvent", agg.TypeName, "(event *eventsourcing.Event) (proto.Message, error) {")
		g.P("	switch event.EventType {")

		for _, evt := range events {
			fullName := string(file.GoPackageName) + "." + evt.MessageName
			g.P("	case \"", fullName, "\":")
			g.P("		msg := &", evt.MessageName, "{}")
			g.P("		if err := proto.Unmarshal(event.Data, msg); err != nil {")
			g.P("			return nil, err")
			g.P("		}")
			g.P("		return msg, nil")
		}

		g.P("	default:")
		g.P("		return nil, fmt.Errorf(\"unknown event type: %s\", event.EventType)")
		g.P("	}")
		g.P("}")
		g.P()
	}
}

// Helper types

type AggregateInfo struct {
	Message     *protogen.Message
	MessageName string
	TypeName    string
	IDField     string
	IDFieldGo   string
}

type CommandInfo struct {
	MessageName       string
	MethodName        string
	AggregateName     string
	ProducesEvents    []string
	UniqueConstraints []ConstraintInfo
}

type EventInfo struct {
	MessageName    string
	AggregateName  string
	AppliesToState []string
	FieldMapping   map[string]string
}

type ConstraintInfo struct {
	IndexName string
	Field     string
	FieldGo   string
	Operation string
}

func findAggregates(file *protogen.File) []*AggregateInfo {
	var aggregates []*AggregateInfo

	// Look for proto messages that match aggregate pattern
	// For now, look for messages that don't end in Command, Event, Request, Response, View
	for _, msg := range file.Messages {
		name := string(msg.Desc.Name())

		// Skip non-aggregate messages
		if strings.HasSuffix(name, "Command") ||
			strings.HasSuffix(name, "Event") ||
			strings.HasSuffix(name, "Request") ||
			strings.HasSuffix(name, "Response") ||
			strings.HasSuffix(name, "View") ||
			strings.HasSuffix(name, "Snapshot") {
			continue
		}

		// Check if this message has an ID field (heuristic for aggregate)
		idField := ""
		idFieldGo := ""
		for _, field := range msg.Fields {
			fieldName := string(field.Desc.Name())
			if strings.HasSuffix(fieldName, "_id") {
				idField = fieldName
				idFieldGo = field.GoName
				break
			}
		}

		if idField != "" {
			aggregates = append(aggregates, &AggregateInfo{
				Message:     msg,
				MessageName: name,
				TypeName:    name,
				IDField:     idField,
				IDFieldGo:   idFieldGo,
			})
		}
	}

	// Fallback to service-based detection if no aggregates found
	if len(aggregates) == 0 {
		aggregates = findAggregatesFromServices(file)
	}

	return aggregates
}

func findCommands(file *protogen.File) []*CommandInfo {
	var commands []*CommandInfo

	// Find aggregate name from service
	aggregateName := ""
	for _, svc := range file.Services {
		name := string(svc.Desc.Name())
		if strings.HasSuffix(name, "CommandService") {
			aggregateName = strings.TrimSuffix(name, "CommandService")
			break
		}
	}

	for _, msg := range file.Messages {
		if !strings.HasSuffix(string(msg.Desc.Name()), "Command") {
			continue
		}

		commands = append(commands, &CommandInfo{
			MessageName:       string(msg.Desc.Name()),
			MethodName:        extractMethodName(string(msg.Desc.Name())),
			AggregateName:     aggregateName,
			ProducesEvents:    []string{inferEventName(string(msg.Desc.Name()))},
			UniqueConstraints: []ConstraintInfo{},
		})
	}

	return commands
}

func findEventsForAggregate(file *protogen.File, aggregateName string) []*EventInfo {
	var events []*EventInfo

	for _, msg := range file.Messages {
		if !strings.HasSuffix(string(msg.Desc.Name()), "Event") {
			continue
		}

		eventName := string(msg.Desc.Name())

		// Check if message has event_options annotation
		if proto.HasExtension(msg.Desc.Options(), eventsourcing.E_EventOptions) {
			opts := proto.GetExtension(msg.Desc.Options(), eventsourcing.E_EventOptions).(*eventsourcing.EventOptions)

			// Only include events that belong to this aggregate
			if opts.GetAggregate() == aggregateName || aggregateName == "" {
				events = append(events, &EventInfo{
					MessageName:    eventName,
					AggregateName:  aggregateName,
					AppliesToState: extractStateFieldsFromEvent(msg),
					FieldMapping:   make(map[string]string),
				})
			}
		} else {
			// Fallback to name heuristic if no event_options annotation
			if strings.Contains(eventName, aggregateName) || aggregateName == "" {
				events = append(events, &EventInfo{
					MessageName:    eventName,
					AggregateName:  aggregateName,
					AppliesToState: extractStateFieldsFromEvent(msg),
					FieldMapping:   make(map[string]string),
				})
			}
		}
	}

	return events
}

func extractStateFieldsFromEvent(msg *protogen.Message) []string {
	var fields []string
	for _, field := range msg.Fields {
		fieldName := string(field.Desc.Name())
		if fieldName != "timestamp" && fieldName != "version" {
			fields = append(fields, fieldName)
		}
	}
	return fields
}

func findAggregatesFromServices(file *protogen.File) []*AggregateInfo {
	// Extract aggregate name from service
	aggregateName := ""
	for _, svc := range file.Services {
		name := string(svc.Desc.Name())
		if strings.HasSuffix(name, "CommandService") {
			aggregateName = strings.TrimSuffix(name, "CommandService")
			break
		}
	}

	if aggregateName == "" {
		return nil
	}

	// Create a synthetic aggregate info
	return []*AggregateInfo{
		{
			Message:     nil,
			MessageName: aggregateName,
			TypeName:    aggregateName,
			IDField:     strings.ToLower(aggregateName) + "_id",
			IDFieldGo:   aggregateName + "Id",
		},
	}
}

// Helper functions

func extractMethodName(commandName string) string {
	return strings.TrimSuffix(commandName, "Command")
}

func toGoName(protoName string) string {
	// Convert snake_case to CamelCase
	parts := strings.Split(protoName, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[0:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func hasField(msg *protogen.Message, fieldName string) bool {
	if msg == nil {
		return false
	}
	for _, field := range msg.Fields {
		if string(field.Desc.Name()) == fieldName {
			return true
		}
	}
	return false
}

func getFieldType(msg *protogen.Message, fieldName string) string {
	if msg == nil {
		return ""
	}
	for _, field := range msg.Fields {
		if string(field.Desc.Name()) == fieldName {
			if field.Enum != nil {
				return string(field.Enum.Desc.Name())
			}
		}
	}
	return ""
}

func inferEventName(commandName string) string {
	// OpenAccountCommand -> AccountOpenedEvent
	method := extractMethodName(commandName)

	// Convert verb to past tense (simple heuristic)
	if strings.HasPrefix(method, "Open") {
		return strings.TrimPrefix(method, "Open") + "OpenedEvent"
	}
	if strings.HasPrefix(method, "Close") {
		return strings.TrimPrefix(method, "Close") + "ClosedEvent"
	}
	if strings.HasPrefix(method, "Create") {
		return strings.TrimPrefix(method, "Create") + "CreatedEvent"
	}
	if strings.HasPrefix(method, "Update") {
		return strings.TrimPrefix(method, "Update") + "UpdatedEvent"
	}
	if strings.HasPrefix(method, "Delete") {
		return strings.TrimPrefix(method, "Delete") + "DeletedEvent"
	}
	if strings.HasPrefix(method, "Deposit") {
		return "MoneyDepositedEvent"
	}
	if strings.HasPrefix(method, "Withdraw") {
		return "MoneyWithdrawnEvent"
	}

	return method + "Event"
}

// ServiceInfo holds information about gRPC services
type ServiceInfo struct {
	Name          string
	Commands      []*protogen.Method
	Queries       []*protogen.Method
	Service       *protogen.Service
	AggregateName string
}

// findServices finds all command and query services in the proto file
func findServices(file *protogen.File) []*ServiceInfo {
	var services []*ServiceInfo

	for _, svc := range file.Services {
		name := string(svc.Desc.Name())

		// Determine aggregate name and service type
		var aggregateName string
		var serviceType string

		if strings.HasSuffix(name, "CommandService") {
			aggregateName = strings.TrimSuffix(name, "CommandService")
			serviceType = "command"
		} else if strings.HasSuffix(name, "QueryService") {
			aggregateName = strings.TrimSuffix(name, "QueryService")
			serviceType = "query"
		} else {
			continue // Skip other services
		}

		info := &ServiceInfo{
			Name:          name,
			Service:       svc,
			AggregateName: aggregateName,
			Commands:      make([]*protogen.Method, 0),
			Queries:       make([]*protogen.Method, 0),
		}

		// Categorize methods
		for _, method := range svc.Methods {
			if serviceType == "command" {
				info.Commands = append(info.Commands, method)
			} else if serviceType == "query" {
				info.Queries = append(info.Queries, method)
			}
		}

		services = append(services, info)
	}

	return services
}

// generateSDKClient generates a type-safe SDK client for commands and queries using Transport
func generateSDKClient(gen *protogen.Plugin, file *protogen.File, aggregates []*AggregateInfo, services []*ServiceInfo) {
	clientFilename := file.GeneratedFilenamePrefix + "_client.pb.go"
	g := gen.NewGeneratedFile(clientFilename, file.GoImportPath)

	// Header
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P("// Client SDK for ", file.Desc.Name())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(")")
	g.P()

	// Generate aggregate-specific client for each aggregate
	for _, agg := range aggregates {
		clientName := agg.TypeName + "Client"

		g.P("// ", clientName, " provides type-safe methods for ", agg.TypeName, " commands and queries")
		g.P("type ", clientName, " struct {")
		g.P("	transport eventsourcing.Transport")
		g.P("}")
		g.P()

		g.P("// New", clientName, " creates a new type-safe client for ", agg.TypeName)
		g.P("func New", clientName, "(transport eventsourcing.Transport) *", clientName, " {")
		g.P("	return &", clientName, "{transport: transport}")
		g.P("}")
		g.P()

		// Find services for this aggregate
		for _, svc := range services {
			if svc.AggregateName != agg.TypeName {
				continue
			}

			// Generate command methods
			for _, method := range svc.Commands {
				methodName := method.GoName
				inputType := g.QualifiedGoIdent(method.Input.GoIdent)
				outputType := g.QualifiedGoIdent(method.Output.GoIdent)
				subject := string(file.Desc.Package()) + "." + svc.Name + "." + methodName

				g.P("// ", methodName, " sends a ", methodName, " command and returns the response")
				g.P("func (c *", clientName, ") ", methodName, "(ctx context.Context, cmd *", inputType, ") (*", outputType, ", *eventsourcing.AppError) {")
				g.P("	// Send request via transport")
				g.P(`	resp, err := c.transport.Request(ctx, "`, subject, `", cmd)`)
				g.P("	if err != nil {")
				g.P("		return nil, &eventsourcing.AppError{")
				g.P(`			Code:    "TRANSPORT_ERROR",`)
				g.P("			Message: err.Error(),")
				g.P("		}")
				g.P("	}")
				g.P()
				g.P("	// Check if request succeeded")
				g.P("	if !resp.Success {")
				g.P("		return nil, resp.GetError()")
				g.P("	}")
				g.P()
				g.P("	// Unpack response data")
				g.P("	result := &", outputType, "{}")
				g.P("	if err := resp.UnpackData(result); err != nil {")
				g.P("		return nil, &eventsourcing.AppError{")
				g.P(`			Code:    "INVALID_RESPONSE",`)
				g.P("			Message: err.Error(),")
				g.P("		}")
				g.P("	}")
				g.P()
				g.P("	return result, nil")
				g.P("}")
				g.P()
			}

			// Generate query methods
			for _, method := range svc.Queries {
				methodName := method.GoName
				inputType := g.QualifiedGoIdent(method.Input.GoIdent)
				outputType := g.QualifiedGoIdent(method.Output.GoIdent)
				subject := string(file.Desc.Package()) + "." + svc.Name + "." + methodName

				g.P("// ", methodName, " executes a ", methodName, " query and returns the result")
				g.P("func (c *", clientName, ") ", methodName, "(ctx context.Context, query *", inputType, ") (*", outputType, ", *eventsourcing.AppError) {")
				g.P("	// Send request via transport")
				g.P(`	resp, err := c.transport.Request(ctx, "`, subject, `", query)`)
				g.P("	if err != nil {")
				g.P("		return nil, &eventsourcing.AppError{")
				g.P(`			Code:    "TRANSPORT_ERROR",`)
				g.P("			Message: err.Error(),")
				g.P("		}")
				g.P("	}")
				g.P()
				g.P("	// Check if request succeeded")
				g.P("	if !resp.Success {")
				g.P("		return nil, resp.GetError()")
				g.P("	}")
				g.P()
				g.P("	// Unpack response data")
				g.P("	result := &", outputType, "{}")
				g.P("	if err := resp.UnpackData(result); err != nil {")
				g.P("		return nil, &eventsourcing.AppError{")
				g.P(`			Code:    "INVALID_RESPONSE",`)
				g.P("			Message: err.Error(),")
				g.P("		}")
				g.P("	}")
				g.P()
				g.P("	return result, nil")
				g.P("}")
				g.P()
			}
		}
	}
}

// findIDField finds the ID field in a message (looks for fields ending with _id)
func findIDField(msg *protogen.Message) string {
	for _, field := range msg.Fields {
		fieldName := string(field.Desc.Name())
		if strings.HasSuffix(fieldName, "_id") {
			return field.GoName
		}
	}
	// Fallback to first string field
	for _, field := range msg.Fields {
		if field.Desc.Kind().String() == "string" {
			return field.GoName
		}
	}
	return "Id"
}

// generateHandlerInterfaces generates handler interfaces for developers to implement
func generateHandlerInterfaces(gen *protogen.Plugin, file *protogen.File, aggregates []*AggregateInfo, services []*ServiceInfo) {
	handlerFilename := file.GeneratedFilenamePrefix + "_handler.pb.go"
	g := gen.NewGeneratedFile(handlerFilename, file.GoImportPath)

	// Header
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P("// Handler interfaces for ", file.Desc.Name())
	g.P("// Developers implement these interfaces to handle commands and queries")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(")")
	g.P()

	// Generate handler interface for each service
	for _, svc := range services {
		handlerName := svc.Name + "Handler"

		g.P("// ", handlerName, " is the interface developers implement to handle ", svc.Name, " requests")
		g.P("type ", handlerName, " interface {")

		// Generate method signatures for commands
		for _, method := range svc.Commands {
			methodName := method.GoName
			inputType := g.QualifiedGoIdent(method.Input.GoIdent)
			outputType := g.QualifiedGoIdent(method.Output.GoIdent)

			g.P("	// ", methodName, " handles the ", methodName, " command")
			g.P("	", methodName, "(ctx context.Context, cmd *", inputType, ") (*", outputType, ", *eventsourcing.AppError)")
		}

		// Generate method signatures for queries
		for _, method := range svc.Queries {
			methodName := method.GoName
			inputType := g.QualifiedGoIdent(method.Input.GoIdent)
			outputType := g.QualifiedGoIdent(method.Output.GoIdent)

			g.P("	// ", methodName, " handles the ", methodName, " query")
			g.P("	", methodName, "(ctx context.Context, query *", inputType, ") (*", outputType, ", *eventsourcing.AppError)")
		}

		g.P("}")
		g.P()
	}
}

// generateServerService generates server-side service that routes requests to handlers
func generateServerService(gen *protogen.Plugin, file *protogen.File, aggregates []*AggregateInfo, services []*ServiceInfo) {
	serverFilename := file.GeneratedFilenamePrefix + "_server.pb.go"
	g := gen.NewGeneratedFile(serverFilename, file.GoImportPath)

	// Header
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P("// Server service for ", file.Desc.Name())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"fmt"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()

	// Generate server for each service
	for _, svc := range services {
		serverName := svc.Name + "Server"
		handlerName := svc.Name + "Handler"

		// Server struct
		g.P("// ", serverName, " handles ", svc.Name, " requests by routing them to the handler")
		g.P("type ", serverName, " struct {")
		g.P("	server  eventsourcing.Server")
		g.P("	handler ", handlerName)
		g.P("}")
		g.P()

		// Constructor
		g.P("// New", serverName, " creates a new server for ", svc.Name)
		g.P("func New", serverName, "(server eventsourcing.Server, handler ", handlerName, ") *", serverName, " {")
		g.P("	return &", serverName, "{")
		g.P("		server:  server,")
		g.P("		handler: handler,")
		g.P("	}")
		g.P("}")
		g.P()

		// Start method
		g.P("// Start registers all handlers and starts the server")
		g.P("func (s *", serverName, ") Start(ctx context.Context) error {")

		// Register handlers for commands
		for _, method := range svc.Commands {
			methodName := method.GoName
			subject := string(file.Desc.Package()) + "." + svc.Name + "." + methodName

			g.P("	// Register ", methodName, " handler")
			g.P(`	if err := s.server.RegisterHandler("`, subject, `", s.handle`, methodName, `); err != nil {`)
			g.P("		return fmt.Errorf(\"failed to register ", methodName, " handler: %w\", err)")
			g.P("	}")
		}

		// Register handlers for queries
		for _, method := range svc.Queries {
			methodName := method.GoName
			subject := string(file.Desc.Package()) + "." + svc.Name + "." + methodName

			g.P("	// Register ", methodName, " handler")
			g.P(`	if err := s.server.RegisterHandler("`, subject, `", s.handle`, methodName, `); err != nil {`)
			g.P("		return fmt.Errorf(\"failed to register ", methodName, " handler: %w\", err)")
			g.P("	}")
		}

		g.P()
		g.P("	return s.server.Start(ctx)")
		g.P("}")
		g.P()

		// Generate handler wrapper methods for commands
		for _, method := range svc.Commands {
			methodName := method.GoName
			inputType := g.QualifiedGoIdent(method.Input.GoIdent)

			g.P("func (s *", serverName, ") handle", methodName, "(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {")
			g.P("	cmd := request.(*", inputType, ")")
			g.P("	result, appErr := s.handler.", methodName, "(ctx, cmd)")
			g.P("	if appErr != nil {")
			g.P("		return &eventsourcing.Response{")
			g.P("			Success: false,")
			g.P("			Error:   appErr,")
			g.P("		}, nil")
			g.P("	}")
			g.P("	return eventsourcing.NewSuccessResponse(result)")
			g.P("}")
			g.P()
		}

		// Generate handler wrapper methods for queries
		for _, method := range svc.Queries {
			methodName := method.GoName
			inputType := g.QualifiedGoIdent(method.Input.GoIdent)

			g.P("func (s *", serverName, ") handle", methodName, "(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {")
			g.P("	query := request.(*", inputType, ")")
			g.P("	result, appErr := s.handler.", methodName, "(ctx, query)")
			g.P("	if appErr != nil {")
			g.P("		return &eventsourcing.Response{")
			g.P("			Success: false,")
			g.P("			Error:   appErr,")
			g.P("		}, nil")
			g.P("	}")
			g.P("	return eventsourcing.NewSuccessResponse(result)")
			g.P("}")
			g.P()
		}

		// Close method
		g.P("// Close stops the server")
		g.P("func (s *", serverName, ") Close() error {")
		g.P("	return s.server.Close()")
		g.P("}")
		g.P()
	}
}

// generateUnifiedSDK generates a unified SDK wrapper that combines client functionality
func generateUnifiedSDK(gen *protogen.Plugin, file *protogen.File, aggregates []*AggregateInfo, services []*ServiceInfo) {
	sdkFilename := file.GeneratedFilenamePrefix + "_sdk.pb.go"
	g := gen.NewGeneratedFile(sdkFilename, file.GoImportPath)

	// Header
	g.P("// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.")
	g.P("// Unified SDK for ", file.Desc.Name())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/plaenen/eventstore/pkg/eventsourcing"`)
	g.P(")")
	g.P()

	// Generate SDK for each aggregate
	for _, agg := range aggregates {
		sdkName := agg.TypeName + "SDK"
		clientName := agg.TypeName + "Client"

		// SDK documentation
		g.P("// ", sdkName, " provides a unified, developer-friendly interface for the ", agg.TypeName, " service.")
		g.P("// It combines all commands and queries into a single client that only requires a transport.")
		g.P("//")
		g.P("// Example usage:")
		g.P("//")
		g.P("//	transport, _ := nats.NewTransport(&nats.TransportConfig{...})")
		g.P("//	sdk := ", file.GoPackageName, ".New", sdkName, "(transport)")
		g.P("//")
		g.P("//	// Execute commands and queries")

		// Find first command as example
		for _, svc := range services {
			if svc.AggregateName == agg.TypeName && len(svc.Commands) > 0 {
				firstCmd := svc.Commands[0]
				cmdName := firstCmd.GoName
				g.P("//	resp, err := sdk.", cmdName, "(ctx, &", file.GoPackageName, ".", firstCmd.Input.GoIdent.GoName, "{...})")
				break
			}
		}

		g.P("type ", sdkName, " struct {")
		g.P("	client *", clientName)
		g.P("}")
		g.P()

		// Constructor
		g.P("// New", sdkName, " creates a new unified SDK for the ", agg.TypeName, " service.")
		g.P("// It only requires a transport - all service clients are created automatically.")
		g.P("func New", sdkName, "(transport eventsourcing.Transport) *", sdkName, " {")
		g.P("	return &", sdkName, "{")
		g.P("		client: New", clientName, "(transport),")
		g.P("	}")
		g.P("}")
		g.P()

		// Generate wrapper methods for commands and queries
		for _, svc := range services {
			if svc.AggregateName != agg.TypeName {
				continue
			}

			// Commands
			if len(svc.Commands) > 0 {
				g.P("// Commands")
				g.P()
			}

			for _, method := range svc.Commands {
				methodName := method.GoName
				inputType := g.QualifiedGoIdent(method.Input.GoIdent)
				outputType := g.QualifiedGoIdent(method.Output.GoIdent)

				// Extract brief description from method name
				description := extractDescription(methodName)

				g.P("// ", methodName, " ", description)
				g.P("func (s *", sdkName, ") ", methodName, "(ctx context.Context, cmd *", inputType, ") (*", outputType, ", *eventsourcing.AppError) {")
				g.P("	return s.client.", methodName, "(ctx, cmd)")
				g.P("}")
				g.P()
			}

			// Queries
			if len(svc.Queries) > 0 {
				g.P("// Queries")
				g.P()
			}

			for _, method := range svc.Queries {
				methodName := method.GoName
				inputType := g.QualifiedGoIdent(method.Input.GoIdent)
				outputType := g.QualifiedGoIdent(method.Output.GoIdent)

				description := extractDescription(methodName)

				g.P("// ", methodName, " ", description)
				g.P("func (s *", sdkName, ") ", methodName, "(ctx context.Context, query *", inputType, ") (*", outputType, ", *eventsourcing.AppError) {")
				g.P("	return s.client.", methodName, "(ctx, query)")
				g.P("}")
				g.P()
			}
		}

		// Utility methods
		g.P("// Transport returns the underlying transport used by this SDK.")
		g.P("// This can be useful for cleanup or advanced use cases.")
		g.P("func (s *", sdkName, ") Transport() eventsourcing.Transport {")
		g.P("	return s.client.transport")
		g.P("}")
		g.P()

		g.P("// Close closes the underlying transport connection.")
		g.P("// This is a convenience method equivalent to calling Transport().Close()")
		g.P("func (s *", sdkName, ") Close() error {")
		g.P("	return s.client.transport.Close()")
		g.P("}")
		g.P()
	}
}

// extractDescription creates a brief description from a method name
func extractDescription(methodName string) string {
	switch {
	case strings.HasPrefix(methodName, "Get"):
		return "retrieves " + strings.ToLower(strings.TrimPrefix(methodName, "Get"))
	case strings.HasPrefix(methodName, "List"):
		return "lists " + strings.ToLower(strings.TrimPrefix(methodName, "List"))
	case strings.HasPrefix(methodName, "Create"):
		return "creates a new " + strings.ToLower(strings.TrimPrefix(methodName, "Create"))
	case strings.HasPrefix(methodName, "Update"):
		return "updates " + strings.ToLower(strings.TrimPrefix(methodName, "Update"))
	case strings.HasPrefix(methodName, "Delete"):
		return "deletes " + strings.ToLower(strings.TrimPrefix(methodName, "Delete"))
	case strings.HasPrefix(methodName, "Open"):
		return "opens " + strings.ToLower(strings.TrimPrefix(methodName, "Open"))
	case strings.HasPrefix(methodName, "Close"):
		return "closes " + strings.ToLower(strings.TrimPrefix(methodName, "Close"))
	case methodName == "Deposit":
		return "adds money to an account"
	case methodName == "Withdraw":
		return "removes money from an account"
	default:
		return "executes " + strings.ToLower(methodName)
	}
}
