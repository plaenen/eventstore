package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// ClientInfo holds information about a generated client.
type ClientInfo struct {
	Name        string // e.g., "Account"
	Package     string // e.g., "accountv1"
	ImportPath  string // e.g., "github.com/plaenen/eventsourcing/examples/pb/account/v1"
	ClientType  string // e.g., "AccountClient"
}

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: generate-unified-sdk <search-root> <output-file>")
		fmt.Println("Example: generate-unified-sdk ./examples/pb ./pkg/sdk/generated.go")
		os.Exit(1)
	}

	searchRoot := os.Args[1]
	outputFile := os.Args[2]

	// Find all generated SDK clients
	clients, err := findSDKClients(searchRoot)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding SDK clients: %v\n", err)
		os.Exit(1)
	}

	if len(clients) == 0 {
		fmt.Println("No SDK clients found")
		return
	}

	// Generate unified SDK
	if err := generateUnifiedSDK(clients, outputFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating unified SDK: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated unified SDK with %d clients: %s\n", len(clients), outputFile)
}

// findSDKClients searches for *_sdk.pb.go files and extracts client information.
func findSDKClients(root string) ([]ClientInfo, error) {
	var clients []ClientInfo

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Look for *_sdk.pb.go files
		if !info.IsDir() && strings.HasSuffix(path, "_sdk.pb.go") {
			client, err := extractClientInfo(path)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Warning: failed to extract client info from %s: %v\n", path, err)
				return nil
			}
			if client != nil {
				clients = append(clients, *client)
			}
		}

		return nil
	})

	return clients, err
}

// extractClientInfo parses a generated SDK file and extracts client information.
func extractClientInfo(filePath string) (*ClientInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var clientType string
	var packageName string = node.Name.Name

	// Find the client struct (e.g., "AccountClient")
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		// Look for types ending with "Client"
		if strings.HasSuffix(typeSpec.Name.Name, "Client") {
			clientType = typeSpec.Name.Name
			return false
		}

		return true
	})

	if clientType == "" {
		return nil, nil // No client found in this file
	}

	// Extract aggregate name from client type (e.g., "AccountClient" -> "Account")
	aggregateName := strings.TrimSuffix(clientType, "Client")

	// Get import path from go.mod context
	// For now, use a heuristic based on the file path
	importPath := getImportPath(filePath, packageName)

	return &ClientInfo{
		Name:       aggregateName,
		Package:    packageName,
		ImportPath: importPath,
		ClientType: clientType,
	}, nil
}

// getImportPath derives the import path from the file path.
func getImportPath(filePath, packageName string) string {
	// Normalize path
	absPath, _ := filepath.Abs(filePath)

	// Look for go.mod to determine module root
	dir := filepath.Dir(absPath)
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			// Found go.mod, extract module path
			modulePath, err := getModulePath(filepath.Join(dir, "go.mod"))
			if err == nil {
				// Calculate relative path from module root
				relPath, _ := filepath.Rel(dir, filepath.Dir(absPath))
				return filepath.Join(modulePath, filepath.ToSlash(relPath))
			}
			break
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			break // Reached root
		}
		dir = parent
	}

	// Fallback: use relative path
	return packageName
}

// getModulePath extracts the module path from go.mod.
func getModulePath(goModPath string) (string, error) {
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return "", err
	}

	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module ")), nil
		}
	}

	return "", fmt.Errorf("module path not found in go.mod")
}

// generateUnifiedSDK generates the unified SDK file.
func generateUnifiedSDK(clients []ClientInfo, outputFile string) error {
	tmpl := template.Must(template.New("unified").Parse(unifiedSDKTemplate))

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, clients); err != nil {
		return err
	}

	// Write to file
	if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
		return err
	}

	return os.WriteFile(outputFile, buf.Bytes(), 0644)
}

const unifiedSDKTemplate = `// Code generated by generate-unified-sdk. DO NOT EDIT.

package unifiedsdk

import (
	"github.com/plaenen/eventsourcing/pkg/sdk"
{{- range . }}
	{{ .Package }} "{{ .ImportPath }}"
{{- end }}
)

// SDK provides a unified interface to all service clients.
// Use New() to create an instance, then access service clients via properties.
//
// Example:
//   s, _ := unifiedsdk.New(unifiedsdk.WithMode(unifiedsdk.DevelopmentMode))
//   s.{{ (index . 0).Name }}.OpenAccount(ctx, cmd, principalID)
type SDK struct {
	client *sdk.Client
{{- range . }}
	{{ .Name }} *{{ .Package }}.{{ .ClientType }}
{{- end }}
}

// New creates a new unified SDK instance with all service clients.
func New(opts ...Option) (*SDK, error) {
	// Build configuration
	config := sdk.DefaultConfig()
	for _, opt := range opts {
		opt(config)
	}

	// Create underlying client
	client, err := sdk.NewClient(config)
	if err != nil {
		return nil, err
	}

	// Initialize all service clients
	return &SDK{
		client: client,
{{- range . }}
		{{ .Name }}: {{ .Package }}.New{{ .ClientType }}(client),
{{- end }}
	}, nil
}

// Option is a functional option for configuring the SDK.
type Option func(*sdk.Config)

// WithMode sets the operational mode.
func WithMode(mode sdk.Mode) Option {
	return func(c *sdk.Config) {
		c.Mode = mode
	}
}

// WithRole sets the client role.
// - sdk.RoleFullStack: Full client with event store (default)
// - sdk.RoleCommandSender: Thin client, only sends commands (no event store)
// - sdk.RoleCommandHandler: Handles commands, requires event store
func WithRole(role sdk.Role) Option {
	return func(c *sdk.Config) {
		c.Role = role
	}
}

// WithNATSURL sets the NATS server URL.
func WithNATSURL(url string) Option {
	return func(c *sdk.Config) {
		c.NATS.URL = url
	}
}

// WithSQLiteDSN sets the SQLite database DSN.
// Only required for RoleFullStack and RoleCommandHandler.
func WithSQLiteDSN(dsn string) Option {
	return func(c *sdk.Config) {
		c.SQLite.DSN = dsn
	}
}

// WithWALMode enables or disables WAL mode for SQLite.
func WithWALMode(enabled bool) Option {
	return func(c *sdk.Config) {
		c.SQLite.WALMode = enabled
	}
}

// Client returns the underlying SDK client for advanced usage.
func (s *SDK) Client() *sdk.Client {
	return s.client
}

// Close closes all connections and releases resources.
func (s *SDK) Close() error {
	return s.client.Close()
}
`
