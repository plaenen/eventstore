// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.
// Server service for v1

package subscriptionv1

import (
	"context"
	"fmt"

	"github.com/plaenen/eventstore/pkg/eventsourcing"
	"google.golang.org/protobuf/proto"
)

// SubscriptionCommandServiceServer handles SubscriptionCommandService requests by routing them to the handler
type SubscriptionCommandServiceServer struct {
	server  eventsourcing.Server
	handler SubscriptionCommandServiceHandler
}

// NewSubscriptionCommandServiceServer creates a new server for SubscriptionCommandService
func NewSubscriptionCommandServiceServer(server eventsourcing.Server, handler SubscriptionCommandServiceHandler) *SubscriptionCommandServiceServer {
	return &SubscriptionCommandServiceServer{
		server:  server,
		handler: handler,
	}
}

// Start registers all handlers and starts the server
func (s *SubscriptionCommandServiceServer) Start(ctx context.Context) error {
	// Register CreateSubscription handler
	if err := s.server.RegisterHandler("subscription.v1.SubscriptionCommandService.CreateSubscription", s.handleCreateSubscription); err != nil {
		return fmt.Errorf("failed to register CreateSubscription handler: %w", err)
	}
	// Register CancelSubscription handler
	if err := s.server.RegisterHandler("subscription.v1.SubscriptionCommandService.CancelSubscription", s.handleCancelSubscription); err != nil {
		return fmt.Errorf("failed to register CancelSubscription handler: %w", err)
	}

	return s.server.Start(ctx)
}

func (s *SubscriptionCommandServiceServer) handleCreateSubscription(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	cmd := request.(*CreateSubscriptionCommand)
	result, appErr := s.handler.CreateSubscription(ctx, cmd)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

func (s *SubscriptionCommandServiceServer) handleCancelSubscription(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	cmd := request.(*CancelSubscriptionCommand)
	result, appErr := s.handler.CancelSubscription(ctx, cmd)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

// Close stops the server
func (s *SubscriptionCommandServiceServer) Close() error {
	return s.server.Close()
}

// SubscriptionQueryServiceServer handles SubscriptionQueryService requests by routing them to the handler
type SubscriptionQueryServiceServer struct {
	server  eventsourcing.Server
	handler SubscriptionQueryServiceHandler
}

// NewSubscriptionQueryServiceServer creates a new server for SubscriptionQueryService
func NewSubscriptionQueryServiceServer(server eventsourcing.Server, handler SubscriptionQueryServiceHandler) *SubscriptionQueryServiceServer {
	return &SubscriptionQueryServiceServer{
		server:  server,
		handler: handler,
	}
}

// Start registers all handlers and starts the server
func (s *SubscriptionQueryServiceServer) Start(ctx context.Context) error {
	// Register GetSubscription handler
	if err := s.server.RegisterHandler("subscription.v1.SubscriptionQueryService.GetSubscription", s.handleGetSubscription); err != nil {
		return fmt.Errorf("failed to register GetSubscription handler: %w", err)
	}

	return s.server.Start(ctx)
}

func (s *SubscriptionQueryServiceServer) handleGetSubscription(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	query := request.(*GetSubscriptionRequest)
	result, appErr := s.handler.GetSubscription(ctx, query)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

// Close stops the server
func (s *SubscriptionQueryServiceServer) Close() error {
	return s.server.Close()
}
