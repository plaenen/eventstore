// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.

package subscriptionv1

import (
	"fmt"

	"github.com/plaenen/eventstore/pkg/eventsourcing"
	"google.golang.org/protobuf/proto"
)

// SubscriptionAggregate is the aggregate root for Subscription domain
// It embeds the proto-defined Subscription for state management
type SubscriptionAggregate struct {
	eventsourcing.AggregateRoot
	*Subscription
}

// NewSubscription creates a new SubscriptionAggregate instance
func NewSubscription(id string) *SubscriptionAggregate {
	return &SubscriptionAggregate{
		AggregateRoot: eventsourcing.NewAggregateRoot(id, "Subscription"),
		Subscription:  &Subscription{},
	}
}

// MarshalSnapshot serializes the aggregate state for snapshots
func (a *SubscriptionAggregate) MarshalSnapshot() ([]byte, error) {
	return proto.Marshal(a.Subscription)
}

// UnmarshalSnapshot deserializes the aggregate state from snapshots
func (a *SubscriptionAggregate) UnmarshalSnapshot(data []byte) error {
	a.Subscription = &Subscription{}
	return proto.Unmarshal(data, a.Subscription)
}

// ID returns the aggregate ID
func (a *SubscriptionAggregate) ID() string {
	return a.SubscriptionId
}

// Type returns the aggregate type name
func (a *SubscriptionAggregate) Type() string {
	return "Subscription"
}

// EmitSubscriptionCreatedEvent is a helper to emit SubscriptionCreatedEvent after validation
// Call this from your custom CreateSubscription implementation
func (a *SubscriptionAggregate) EmitSubscriptionCreatedEvent(event *SubscriptionCreatedEvent, metadata eventsourcing.EventMetadata) error {
	return a.ApplyChange(event, "subscriptionv1.SubscriptionCreatedEvent", metadata)
}

// EmitCancelSubscriptionEvent is a helper to emit CancelSubscriptionEvent after validation
// Call this from your custom CancelSubscription implementation
func (a *SubscriptionAggregate) EmitCancelSubscriptionEvent(event *CancelSubscriptionEvent, metadata eventsourcing.EventMetadata) error {
	return a.ApplyChange(event, "subscriptionv1.CancelSubscriptionEvent", metadata)
}

// SubscriptionRepository provides persistence for Subscription
type SubscriptionRepository struct {
	*eventsourcing.BaseRepository[*SubscriptionAggregate]
}

// NewSubscriptionRepository creates a new repository
func NewSubscriptionRepository(eventStore eventsourcing.EventStore) *SubscriptionRepository {
	return &SubscriptionRepository{
		BaseRepository: eventsourcing.NewRepository[*SubscriptionAggregate](
			eventStore,
			"Subscription",
			func(id string) *SubscriptionAggregate {
				return NewSubscription(id)
			},
			func(agg *SubscriptionAggregate, event *eventsourcing.Event) error {
				// Deserialize and apply event
				msg, err := deserializeEventSubscription(event)
				if err != nil {
					return err
				}
				return agg.ApplyEvent(msg)
			},
		),
	}
}

func deserializeEventSubscription(event *eventsourcing.Event) (proto.Message, error) {
	switch event.EventType {
	default:
		return nil, fmt.Errorf("unknown event type: %s", event.EventType)
	}
}
