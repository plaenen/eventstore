// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.

package subscriptionv1

import (
	"fmt"

	"github.com/plaenen/eventstore/pkg/eventsourcing"
	"google.golang.org/protobuf/proto"
)

// SubscriptionAggregate is the aggregate root for Subscription domain
// It embeds the proto-defined Subscription for state management
type SubscriptionAggregate struct {
	eventsourcing.AggregateRoot
	*Subscription
}

// NewSubscription creates a new SubscriptionAggregate instance
func NewSubscription(id string) *SubscriptionAggregate {
	return &SubscriptionAggregate{
		AggregateRoot: eventsourcing.NewAggregateRoot(id, "Subscription"),
		Subscription:  &Subscription{},
	}
}

// MarshalSnapshot serializes the aggregate state for snapshots
func (a *SubscriptionAggregate) MarshalSnapshot() ([]byte, error) {
	return proto.Marshal(a.Subscription)
}

// UnmarshalSnapshot deserializes the aggregate state from snapshots
func (a *SubscriptionAggregate) UnmarshalSnapshot(data []byte) error {
	a.Subscription = &Subscription{}
	return proto.Unmarshal(data, a.Subscription)
}

// ID returns the aggregate ID
func (a *SubscriptionAggregate) ID() string {
	return a.SubscriptionId
}

// Type returns the aggregate type name
func (a *SubscriptionAggregate) Type() string {
	return "Subscription"
}

// ApplyEvent applies an event to the Subscription aggregate
// This method routes events to their specific applier methods
func (a *SubscriptionAggregate) ApplyEvent(event proto.Message) error {
	switch e := event.(type) {
	case *SubscriptionCreatedEvent:
		return a.ApplySubscriptionCreatedEvent(e)
	case *SubscriptionCancelledEvent:
		return a.ApplySubscriptionCancelledEvent(e)
	default:
		return fmt.Errorf("unknown event type: %T", event)
	}
}

// SubscriptionEventApplier defines methods for applying events to Subscription
// Developers must implement these methods to define how events change aggregate state
type SubscriptionEventApplier interface {
	// ApplySubscriptionCreatedEvent applies the SubscriptionCreatedEvent to the aggregate state
	ApplySubscriptionCreatedEvent(e *SubscriptionCreatedEvent) error
	// ApplySubscriptionCancelledEvent applies the SubscriptionCancelledEvent to the aggregate state
	ApplySubscriptionCancelledEvent(e *SubscriptionCancelledEvent) error
}

// The SubscriptionAggregate must implement SubscriptionEventApplier
// Developer implements these methods in a separate file (not generated)

// SubscriptionRepository provides persistence for Subscription
type SubscriptionRepository struct {
	*eventsourcing.BaseRepository[*SubscriptionAggregate]
}

// NewSubscriptionRepository creates a new repository
func NewSubscriptionRepository(eventStore eventsourcing.EventStore) *SubscriptionRepository {
	return &SubscriptionRepository{
		BaseRepository: eventsourcing.NewRepository[*SubscriptionAggregate](
			eventStore,
			"Subscription",
			func(id string) *SubscriptionAggregate {
				return NewSubscription(id)
			},
			func(agg *SubscriptionAggregate, event *eventsourcing.Event) error {
				// Deserialize and apply event
				msg, err := deserializeEventSubscription(event)
				if err != nil {
					return err
				}
				return agg.ApplyEvent(msg)
			},
		),
	}
}

func deserializeEventSubscription(event *eventsourcing.Event) (proto.Message, error) {
	switch event.EventType {
	case "subscriptionv1.SubscriptionCreatedEvent":
		msg := &SubscriptionCreatedEvent{}
		if err := proto.Unmarshal(event.Data, msg); err != nil {
			return nil, err
		}
		return msg, nil
	case "subscriptionv1.SubscriptionCancelledEvent":
		msg := &SubscriptionCancelledEvent{}
		if err := proto.Unmarshal(event.Data, msg); err != nil {
			return nil, err
		}
		return msg, nil
	default:
		return nil, fmt.Errorf("unknown event type: %s", event.EventType)
	}
}
