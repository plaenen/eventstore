// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.

package accountv1

import (
	"fmt"

	"github.com/plaenen/eventstore/pkg/eventsourcing"
	"google.golang.org/protobuf/proto"
)

// AccountAggregate is the aggregate root for Account domain
// It embeds the proto-defined Account for state management
type AccountAggregate struct {
	eventsourcing.AggregateRoot
	*Account
}

// NewAccount creates a new AccountAggregate instance
func NewAccount(id string) *AccountAggregate {
	return &AccountAggregate{
		AggregateRoot: eventsourcing.NewAggregateRoot(id, "Account"),
		Account:       &Account{},
	}
}

// MarshalSnapshot serializes the aggregate state for snapshots
func (a *AccountAggregate) MarshalSnapshot() ([]byte, error) {
	return proto.Marshal(a.Account)
}

// UnmarshalSnapshot deserializes the aggregate state from snapshots
func (a *AccountAggregate) UnmarshalSnapshot(data []byte) error {
	a.Account = &Account{}
	return proto.Unmarshal(data, a.Account)
}

// ID returns the aggregate ID
func (a *AccountAggregate) ID() string {
	return a.AccountId
}

// Type returns the aggregate type name
func (a *AccountAggregate) Type() string {
	return "Account"
}

// EmitAccountOpenedEvent is a helper to emit AccountOpenedEvent after validation
// Call this from your custom OpenAccount implementation
func (a *AccountAggregate) EmitAccountOpenedEvent(event *AccountOpenedEvent, metadata eventsourcing.EventMetadata) error {
	return a.ApplyChange(event, "accountv1.AccountOpenedEvent", metadata)
}

// EmitMoneyDepositedEvent is a helper to emit MoneyDepositedEvent after validation
// Call this from your custom Deposit implementation
func (a *AccountAggregate) EmitMoneyDepositedEvent(event *MoneyDepositedEvent, metadata eventsourcing.EventMetadata) error {
	return a.ApplyChange(event, "accountv1.MoneyDepositedEvent", metadata)
}

// EmitMoneyWithdrawnEvent is a helper to emit MoneyWithdrawnEvent after validation
// Call this from your custom Withdraw implementation
func (a *AccountAggregate) EmitMoneyWithdrawnEvent(event *MoneyWithdrawnEvent, metadata eventsourcing.EventMetadata) error {
	return a.ApplyChange(event, "accountv1.MoneyWithdrawnEvent", metadata)
}

// EmitAccountClosedEvent is a helper to emit AccountClosedEvent after validation
// Call this from your custom CloseAccount implementation
func (a *AccountAggregate) EmitAccountClosedEvent(event *AccountClosedEvent, metadata eventsourcing.EventMetadata) error {
	return a.ApplyChange(event, "accountv1.AccountClosedEvent", metadata)
}

// ApplyEvent applies an event to the Account aggregate
// This method routes events to their specific applier methods
func (a *AccountAggregate) ApplyEvent(event proto.Message) error {
	switch e := event.(type) {
	case *AccountOpenedEvent:
		return a.ApplyAccountOpenedEvent(e)
	case *MoneyDepositedEvent:
		return a.ApplyMoneyDepositedEvent(e)
	case *MoneyWithdrawnEvent:
		return a.ApplyMoneyWithdrawnEvent(e)
	case *AccountClosedEvent:
		return a.ApplyAccountClosedEvent(e)
	default:
		return fmt.Errorf("unknown event type: %T", event)
	}
}

// AccountEventApplier defines methods for applying events to Account
// Developers must implement these methods to define how events change aggregate state
type AccountEventApplier interface {
	// ApplyAccountOpenedEvent applies the AccountOpenedEvent to the aggregate state
	ApplyAccountOpenedEvent(e *AccountOpenedEvent) error
	// ApplyMoneyDepositedEvent applies the MoneyDepositedEvent to the aggregate state
	ApplyMoneyDepositedEvent(e *MoneyDepositedEvent) error
	// ApplyMoneyWithdrawnEvent applies the MoneyWithdrawnEvent to the aggregate state
	ApplyMoneyWithdrawnEvent(e *MoneyWithdrawnEvent) error
	// ApplyAccountClosedEvent applies the AccountClosedEvent to the aggregate state
	ApplyAccountClosedEvent(e *AccountClosedEvent) error
}

// The AccountAggregate must implement AccountEventApplier
// Developer implements these methods in a separate file (not generated)

// AccountRepository provides persistence for Account
type AccountRepository struct {
	*eventsourcing.BaseRepository[*AccountAggregate]
}

// NewAccountRepository creates a new repository
func NewAccountRepository(eventStore eventsourcing.EventStore) *AccountRepository {
	return &AccountRepository{
		BaseRepository: eventsourcing.NewRepository[*AccountAggregate](
			eventStore,
			"Account",
			func(id string) *AccountAggregate {
				return NewAccount(id)
			},
			func(agg *AccountAggregate, event *eventsourcing.Event) error {
				// Deserialize and apply event
				msg, err := deserializeEventAccount(event)
				if err != nil {
					return err
				}
				return agg.ApplyEvent(msg)
			},
		),
	}
}

func deserializeEventAccount(event *eventsourcing.Event) (proto.Message, error) {
	switch event.EventType {
	case "accountv1.AccountOpenedEvent":
		msg := &AccountOpenedEvent{}
		if err := proto.Unmarshal(event.Data, msg); err != nil {
			return nil, err
		}
		return msg, nil
	case "accountv1.MoneyDepositedEvent":
		msg := &MoneyDepositedEvent{}
		if err := proto.Unmarshal(event.Data, msg); err != nil {
			return nil, err
		}
		return msg, nil
	case "accountv1.MoneyWithdrawnEvent":
		msg := &MoneyWithdrawnEvent{}
		if err := proto.Unmarshal(event.Data, msg); err != nil {
			return nil, err
		}
		return msg, nil
	case "accountv1.AccountClosedEvent":
		msg := &AccountClosedEvent{}
		if err := proto.Unmarshal(event.Data, msg); err != nil {
			return nil, err
		}
		return msg, nil
	default:
		return nil, fmt.Errorf("unknown event type: %s", event.EventType)
	}
}
