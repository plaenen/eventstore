// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.
// version: 0.0.4
// Server service for v1

package accountv1

import (
	"context"
	"fmt"

	"github.com/plaenen/eventstore/pkg/eventsourcing"
	"google.golang.org/protobuf/proto"
)

// AccountCommandServiceServer handles AccountCommandService requests by routing them to the handler
type AccountCommandServiceServer struct {
	server  eventsourcing.Server
	handler AccountCommandServiceHandler
}

// NewAccountCommandServiceServer creates a new server for AccountCommandService
func NewAccountCommandServiceServer(server eventsourcing.Server, handler AccountCommandServiceHandler) *AccountCommandServiceServer {
	return &AccountCommandServiceServer{
		server:  server,
		handler: handler,
	}
}

// Start registers all handlers and starts the server
func (s *AccountCommandServiceServer) Start(ctx context.Context) error {
	// Register OpenAccount handler
	if err := s.server.RegisterHandler("account.v1.AccountCommandService.OpenAccount", s.handleOpenAccount); err != nil {
		return fmt.Errorf("failed to register OpenAccount handler: %w", err)
	}
	// Register Deposit handler
	if err := s.server.RegisterHandler("account.v1.AccountCommandService.Deposit", s.handleDeposit); err != nil {
		return fmt.Errorf("failed to register Deposit handler: %w", err)
	}
	// Register Withdraw handler
	if err := s.server.RegisterHandler("account.v1.AccountCommandService.Withdraw", s.handleWithdraw); err != nil {
		return fmt.Errorf("failed to register Withdraw handler: %w", err)
	}
	// Register CloseAccount handler
	if err := s.server.RegisterHandler("account.v1.AccountCommandService.CloseAccount", s.handleCloseAccount); err != nil {
		return fmt.Errorf("failed to register CloseAccount handler: %w", err)
	}

	return s.server.Start(ctx)
}

func (s *AccountCommandServiceServer) handleOpenAccount(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	cmd := request.(*OpenAccountCommand)
	result, appErr := s.handler.OpenAccount(ctx, cmd)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

func (s *AccountCommandServiceServer) handleDeposit(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	cmd := request.(*DepositCommand)
	result, appErr := s.handler.Deposit(ctx, cmd)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

func (s *AccountCommandServiceServer) handleWithdraw(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	cmd := request.(*WithdrawCommand)
	result, appErr := s.handler.Withdraw(ctx, cmd)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

func (s *AccountCommandServiceServer) handleCloseAccount(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	cmd := request.(*CloseAccountCommand)
	result, appErr := s.handler.CloseAccount(ctx, cmd)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

// Close stops the server
func (s *AccountCommandServiceServer) Close() error {
	return s.server.Close()
}

// AccountQueryServiceServer handles AccountQueryService requests by routing them to the handler
type AccountQueryServiceServer struct {
	server  eventsourcing.Server
	handler AccountQueryServiceHandler
}

// NewAccountQueryServiceServer creates a new server for AccountQueryService
func NewAccountQueryServiceServer(server eventsourcing.Server, handler AccountQueryServiceHandler) *AccountQueryServiceServer {
	return &AccountQueryServiceServer{
		server:  server,
		handler: handler,
	}
}

// Start registers all handlers and starts the server
func (s *AccountQueryServiceServer) Start(ctx context.Context) error {
	// Register GetAccount handler
	if err := s.server.RegisterHandler("account.v1.AccountQueryService.GetAccount", s.handleGetAccount); err != nil {
		return fmt.Errorf("failed to register GetAccount handler: %w", err)
	}
	// Register ListAccounts handler
	if err := s.server.RegisterHandler("account.v1.AccountQueryService.ListAccounts", s.handleListAccounts); err != nil {
		return fmt.Errorf("failed to register ListAccounts handler: %w", err)
	}
	// Register GetAccountBalance handler
	if err := s.server.RegisterHandler("account.v1.AccountQueryService.GetAccountBalance", s.handleGetAccountBalance); err != nil {
		return fmt.Errorf("failed to register GetAccountBalance handler: %w", err)
	}
	// Register GetAccountHistory handler
	if err := s.server.RegisterHandler("account.v1.AccountQueryService.GetAccountHistory", s.handleGetAccountHistory); err != nil {
		return fmt.Errorf("failed to register GetAccountHistory handler: %w", err)
	}

	return s.server.Start(ctx)
}

func (s *AccountQueryServiceServer) handleGetAccount(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	query := request.(*GetAccountRequest)
	result, appErr := s.handler.GetAccount(ctx, query)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

func (s *AccountQueryServiceServer) handleListAccounts(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	query := request.(*ListAccountsRequest)
	result, appErr := s.handler.ListAccounts(ctx, query)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

func (s *AccountQueryServiceServer) handleGetAccountBalance(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	query := request.(*GetAccountBalanceRequest)
	result, appErr := s.handler.GetAccountBalance(ctx, query)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

func (s *AccountQueryServiceServer) handleGetAccountHistory(ctx context.Context, request proto.Message) (*eventsourcing.Response, error) {
	query := request.(*GetAccountHistoryRequest)
	result, appErr := s.handler.GetAccountHistory(ctx, query)
	if appErr != nil {
		return &eventsourcing.Response{
			Success: false,
			Error:   appErr,
		}, nil
	}
	return eventsourcing.NewSuccessResponse(result)
}

// Close stops the server
func (s *AccountQueryServiceServer) Close() error {
	return s.server.Close()
}
