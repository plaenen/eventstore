# Event Sourcing Examples

This directory demonstrates the event sourcing framework with a comprehensive demo.

## Directory Structure

```
examples/
├── pb/                     # Protocol buffer code (generated + extensions)
│   ├── account/v1/
│   │   ├── *.pb.go              # Generated by protoc-gen-go (DO NOT EDIT)
│   │   ├── *.connect.go         # Generated by protoc-gen-connect (DO NOT EDIT)
│   │   ├── *_aggregate.pb.go    # Generated event sourcing code (DO NOT EDIT)
│   │   ├── *_client.pb.go       # Generated client SDK (DO NOT EDIT)
│   │   ├── *_handler.pb.go      # Generated handler interfaces (DO NOT EDIT)
│   │   └── account_appliers.go  # ✍️  HAND-WRITTEN (maintained by developers)
│   └── README.md
│
├── bankaccount/
│   └── handlers/
│       ├── command_handler.go   # ✍️  Business logic for commands
│       └── query_handler.go     # ✍️  Business logic for queries
│
└── bankaccount_sqlite_observability_demo.go  # Comprehensive demo
```

## File Naming Convention

The key to understanding what's generated vs hand-written is the file suffix:

| Pattern | Type | Editable? |
|---------|------|-----------|
| `*.pb.go` | Generated by protoc | ❌ Never edit |
| `*.connect.go` | Generated by connectrpc | ❌ Never edit |
| `*_aggregate.pb.go` | Generated event sourcing boilerplate | ❌ Never edit |
| `*_client.pb.go` | Generated client SDK | ❌ Never edit |
| `*_handler.pb.go` | Generated handler interfaces | ❌ Never edit |
| `*.go` (no suffix) | Hand-written by developers | ✅ Maintain these |

**Rule: Files ending in `.pb.go` or `.connect.go` are generated. Plain `.go` files are yours.**

## Why are Hand-Written Files in `pb/`?

**Short answer:** Go's type system requires it.

**Long answer:** You cannot add methods to types from other packages in Go. Since `AccountAggregate` is defined in `package accountv1` (in the generated `account_aggregate.pb.go`), the applier methods must also be in `package accountv1`.

This means the appliers must be in the same directory as the generated code.

### This is Standard Go Practice

This pattern is used throughout the Go ecosystem:
- gRPC projects have custom interceptors in the same package as generated stubs
- Protocol buffer projects add custom methods to generated message types
- The convention is: **`.pb.go` = generated, `.go` = custom**

## Best Practices

### ✅ DO
- **Clear naming**: Never use `.pb.go` or `.connect.go` for custom files
- **Clear headers**: Mark custom files with prominent comments
- **Minimal appliers**: Keep event appliers simple - just update state
- **Business logic in handlers**: Put complex logic in `bankaccount/handlers/`

### ❌ DON'T
- Edit `.pb.go` or `.connect.go` files
- Add business logic to appliers (keep them thin)
- Assume all `.go` files in `pb/` are generated (check the suffix!)

## Code Organization

```
pb/account/v1/
├── account_aggregate.pb.go    # Generated: Defines AccountAggregate type
│                              # Generated: Defines ApplyEvent() router
│                              # Generated: Documents where to implement appliers
│
└── account_appliers.go        # ✍️  Hand-written: Implements Apply*Event() methods
                               # ✍️  Thin adapters that update aggregate state
                               # ✍️  Complex logic delegated to handlers/

bankaccount/handlers/
├── command_handler.go         # ✍️  Business validation
│                              # ✍️  Calls aggregate.ApplyChange()
│                              # ✍️  Handles unique constraints
│
└── query_handler.go           # ✍️  Read-model queries
```

## Example: Event Applier

**Generated code** (`account_aggregate.pb.go`) defines the router:

```go
func (a *AccountAggregate) ApplyEvent(event proto.Message) error {
    switch e := event.(type) {
    case *AccountOpenedEvent:
        return a.ApplyAccountOpenedEvent(e)  // Calls your method
    // ...
    }
}
```

**Your code** (`account_appliers.go`) implements the method:

```go
// ApplyAccountOpenedEvent applies the event to aggregate state
func (a *AccountAggregate) ApplyAccountOpenedEvent(e *AccountOpenedEvent) error {
    a.AccountId = e.AccountId
    a.OwnerName = e.OwnerName
    a.Balance = e.InitialBalance
    a.Status = AccountStatus_ACCOUNT_STATUS_OPEN
    return nil
}
```

**Business logic** (`handlers/command_handler.go`) orchestrates:

```go
func (h *AccountCommandHandler) OpenAccount(ctx context.Context, cmd *OpenAccountCommand) (*OpenAccountResponse, *eventsourcing.AppError) {
    // Validation
    if cmd.OwnerName == "" {
        return nil, &eventsourcing.AppError{Code: "INVALID_OWNER_NAME"}
    }

    // Create aggregate
    agg := accountv1.NewAccount(cmd.AccountId)

    // Create and apply event
    event := &accountv1.AccountOpenedEvent{ /*...*/ }
    agg.AggregateRoot.ApplyChange(event, "accountv1.AccountOpenedEvent", metadata)

    // Save
    h.repo.Save(agg)
}
```

## Regenerating Code

```bash
# From examples directory
buf generate
```

This regenerates all `.pb.go` and `.connect.go` files.
Your `.go` files (like `account_appliers.go`) are left untouched.

## Summary

| Goal | Pattern |
|------|---------|
| Add methods to generated types | Same package, different file, no `.pb.go` suffix |
| Keep code organized | Generated files have `.pb.go`/`.connect.go` suffix |
| Separate concerns | Appliers in `pb/`, business logic in `handlers/` |
| Extend generated code | ✅ Add files with `.go` suffix |
| Modify generated code | ❌ Never edit `.pb.go` files |
