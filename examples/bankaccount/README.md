# Bank Account Example - Regeneration-Safe Pattern

This example demonstrates the regeneration-safe code generation pattern for event sourcing aggregates.

## Architecture

The code is split into **generated** and **custom** files:

### Generated Files (Safe to Regenerate)

**`examples/pb/account_aggregate.pb.go`** - Generated by `protoc-gen-eventsourcing`

Contains:
- `Account` struct with state fields
- `NewAccount()` constructor
- Helper methods: `emitAccountOpenedEvent()`, `emitDepositEvent()`, etc.
- Event appliers: `applyAccountOpenedEvent()`, `applyMoneyDepositedEvent()`, etc.
- `AccountRepository` with event deserializer

These are **mechanical implementations** without business logic. You can regenerate this file anytime without losing custom code.

### Custom Files (Developer Written)

**`examples/bankaccount/account.go`** - Written by developers

Contains:
- Command handlers with business logic: `OpenAccount()`, `Deposit()`, `Withdraw()`, `CloseAccount()`
- Validation rules
- Business calculations
- Domain logic

These files are **never touched by code generation** and contain your business logic.

## How It Works

### Generated Base Code

```go
// Generated in account_aggregate.pb.go
type Account struct {
    eventsourcing.AggregateRoot

    // State
    Balance   string
    AccountId string
    OwnerName string
    Status    AccountStatus
}

// Helper to emit events (generated)
func (a *Account) emitDepositEvent(event *DepositEvent, metadata eventsourcing.EventMetadata) error {
    return a.ApplyChange(event, "examples.DepositEvent", metadata)
}

// Event applier (generated, mechanical state update)
func (a *Account) applyMoneyDepositedEvent(e *MoneyDepositedEvent) error {
    a.AccountId = e.AccountId
    a.Balance = e.NewBalance
    return nil
}
```

### Custom Business Logic

```go
// Written by developer in account.go
func (a *pb.Account) Deposit(ctx context.Context, cmd *pb.DepositCommand, metadata eventsourcing.EventMetadata) error {
    // Business validation
    if a.Status != pb.ACCOUNT_STATUS_OPEN {
        return fmt.Errorf("account is not open")
    }

    // Parse amounts
    amount := new(big.Float)
    if _, ok := amount.SetString(cmd.Amount); !ok {
        return fmt.Errorf("invalid deposit amount: %s", cmd.Amount)
    }

    // Calculate new balance
    currentBalance := new(big.Float)
    currentBalance.SetString(a.Balance)
    newBalance := new(big.Float).Add(currentBalance, amount)

    // Create event
    event := &pb.MoneyDepositedEvent{
        AccountId:  cmd.AccountId,
        Amount:     cmd.Amount,
        NewBalance: newBalance.String(),
        Timestamp:  time.Now().Unix(),
    }

    // Use generated helper
    return a.emitDepositEvent(event, metadata)
}
```

## Regeneration Workflow

1. **Modify proto files** (`examples/proto/account.proto`)
2. **Run generation**: `task generate`
3. **Generated files are updated** - No business logic is lost!
4. **Custom files are untouched** - Your business logic remains intact

## Benefits

✅ **Safe Regeneration**: Run `task generate` anytime without fear of losing code
✅ **Clean Separation**: Generated (mechanical) vs. custom (business logic)
✅ **Type Safety**: Proto changes propagate to Go types automatically
✅ **DRY**: Event emission, serialization, deserialization all generated
✅ **Testable**: Business logic in separate files is easy to test

## File Structure

```
examples/
├── proto/
│   └── account.proto              # Proto definitions
├── pb/
│   ├── account.pb.go              # Generated by protoc
│   └── account_aggregate.pb.go    # Generated by protoc-gen-eventsourcing ⚡
└── bankaccount/
    └── account.go                 # Custom business logic ✍️
```

## Development Workflow

### Adding a New Command

1. **Add proto definitions**:
```protobuf
message TransferCommand {
  string from_account_id = 1;
  string to_account_id = 2;
  string amount = 3;
}

message MoneyTransferredEvent {
  string from_account_id = 1;
  string to_account_id = 2;
  string amount = 3;
  int64 timestamp = 4;
}
```

2. **Regenerate**: `task generate`
   - Helper method `emitMoneyTransferredEvent()` is auto-generated
   - Event applier `applyMoneyTransferredEvent()` is auto-generated

3. **Write business logic** in `account.go`:
```go
func (a *pb.Account) Transfer(ctx context.Context, cmd *pb.TransferCommand, metadata eventsourcing.EventMetadata) error {
    // Your validation and business logic here
    event := &pb.MoneyTransferredEvent{...}
    return a.emitMoneyTransferredEvent(event, metadata)
}
```

4. **Business logic is safe** - Regenerate anytime!

## Testing

Test business logic in `account_test.go`:

```go
func TestDeposit_InsufficientFunds(t *testing.T) {
    account := pb.NewAccount("123")
    account.Balance = "100"
    account.Status = pb.ACCOUNT_STATUS_OPEN

    cmd := &pb.WithdrawCommand{
        AccountId: "123",
        Amount: "200",
    }

    err := account.Withdraw(context.Background(), cmd, eventsourcing.EventMetadata{})
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "insufficient balance")
}
```

## Summary

This pattern ensures **code generation never overwrites your business logic**. Generated files contain mechanical boilerplate, while your custom files contain domain logic. Run `task generate` as often as needed!
