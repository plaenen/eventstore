# Complete Bank Account Example with Code Generation

This example demonstrates the full workflow of building a CQRS/Event Sourcing application with automatic code generation.

## Step 1: Define Your Domain (Proto)

**proto/account.proto**
```protobuf
syntax = "proto3";

package bankaccount;

option go_package = "github.com/plaenen/eventstore/examples/bankaccount/proto";

// Command Service (Write Side)
service AccountCommandService {
  rpc OpenAccount(OpenAccountCommand) returns (OpenAccountResponse);
  rpc Deposit(DepositCommand) returns (DepositResponse);
  rpc Withdraw(WithdrawCommand) returns (WithdrawResponse);
  rpc CloseAccount(CloseAccountCommand) returns (CloseAccountResponse);
}

// Query Service (Read Side)
service AccountQueryService {
  rpc GetAccount(GetAccountRequest) returns (AccountView);
  rpc ListAccounts(ListAccountsRequest) returns (ListAccountsResponse);
  rpc GetAccountBalance(GetAccountBalanceRequest) returns (BalanceView);
}

// Commands
message OpenAccountCommand {
  string account_id = 1;
  string owner_name = 2;
  string initial_balance = 3;
}

message DepositCommand {
  string account_id = 1;
  string amount = 2;
}

message WithdrawCommand {
  string account_id = 1;
  string amount = 2;
}

// Events (for event sourcing)
message AccountOpenedEvent {
  string account_id = 1;
  string owner_name = 2;
  string initial_balance = 3;
  int64 timestamp = 4;
}

message MoneyDepositedEvent {
  string account_id = 1;
  string amount = 2;
  string new_balance = 3;
  int64 timestamp = 4;
}

message MoneyWithdrawnEvent {
  string account_id = 1;
  string amount = 2;
  string new_balance = 3;
  int64 timestamp = 4;
}

// Views (for queries)
message AccountView {
  string account_id = 1;
  string owner_name = 2;
  string balance = 3;
  AccountStatus status = 4;
  int64 version = 5;
}

enum AccountStatus {
  ACCOUNT_STATUS_UNSPECIFIED = 0;
  ACCOUNT_STATUS_OPEN = 1;
  ACCOUNT_STATUS_CLOSED = 2;
}
```

## Step 2: Generate Code

**buf.gen.yaml**
```yaml
version: v2
plugins:
  # Generate protobuf messages
  - remote: buf.build/protocolbuffers/go
    out: .
    opt:
      - paths=source_relative

  # Generate Connect RPC
  - remote: buf.build/connectrpc/go
    out: .
    opt:
      - paths=source_relative

  # Generate Event Sourcing boilerplate
  - local: ../../protoc-gen-eventsourcing
    out: domain
    opt:
      - paths=source_relative
```

Run generation:
```bash
buf generate
```

## Step 3: Generated Code

The plugin generates **proto/account_aggregate.pb.go**:

```go
// Code generated by protoc-gen-eventsourcing. DO NOT EDIT.

package proto

import (
	"context"
	"fmt"
	"time"
	"github.com/plaenen/eventstore/pkg/eventsourcing"
	"google.golang.org/protobuf/proto"
)

// Account is the aggregate root for Account domain
type Account struct {
	eventsourcing.AggregateRoot

	// State
	AccountId      string
	OwnerName      string
	InitialBalance string
}

// NewAccount creates a new Account instance
func NewAccount(id string) *Account {
	return &Account{
		AggregateRoot: eventsourcing.NewAggregateRoot(id, "Account"),
	}
}

// OpenAccount handles the OpenAccountCommand command
func (a *Account) OpenAccount(ctx context.Context, cmd *OpenAccountCommand, metadata eventsourcing.EventMetadata) error {
	// TODO: Add business logic validation here

	// Create event
	event := &AccountOpenedEvent{
		AccountId:      cmd.AccountId,
		OwnerName:      cmd.OwnerName,
		InitialBalance: cmd.InitialBalance,
		Timestamp:      time.Now().Unix(),
	}

	// Apply change with unique constraints
	constraints := []eventsourcing.UniqueConstraint{
		{
			IndexName: "account_id",
			Value:     cmd.AccountId,
			Operation: eventsourcing.ConstraintClaim,
		},
	}
	return a.ApplyChangeWithConstraints(event, "bankaccount.AccountOpenedEvent", metadata, constraints)
}

// Deposit handles the DepositCommand command
func (a *Account) Deposit(ctx context.Context, cmd *DepositCommand, metadata eventsourcing.EventMetadata) error {
	// TODO: Add business logic validation here

	event := &MoneyDepositedEvent{
		AccountId:  cmd.AccountId,
		Amount:     cmd.Amount,
		NewBalance: a.calculateNewBalance(cmd.Amount), // You implement this
		Timestamp:  time.Now().Unix(),
	}

	return a.ApplyChange(event, "bankaccount.MoneyDepositedEvent", metadata)
}

// ApplyEvent applies an event to the Account aggregate
func (a *Account) ApplyEvent(event proto.Message) error {
	switch e := event.(type) {
	case *AccountOpenedEvent:
		return a.applyAccountOpenedEvent(e)
	case *MoneyDepositedEvent:
		return a.applyMoneyDepositedEvent(e)
	case *MoneyWithdrawnEvent:
		return a.applyMoneyWithdrawnEvent(e)
	default:
		return fmt.Errorf("unknown event type: %T", event)
	}
}

func (a *Account) applyAccountOpenedEvent(e *AccountOpenedEvent) error {
	a.AccountId = e.AccountId
	a.OwnerName = e.OwnerName
	a.InitialBalance = e.InitialBalance
	return nil
}

func (a *Account) applyMoneyDepositedEvent(e *MoneyDepositedEvent) error {
	a.InitialBalance = e.NewBalance
	return nil
}

// AccountRepository provides persistence for Account
type AccountRepository struct {
	*eventsourcing.BaseRepository[*Account]
}

// NewAccountRepository creates a new repository
func NewAccountRepository(eventStore eventsourcing.EventStore) *AccountRepository {
	return &AccountRepository{
		BaseRepository: eventsourcing.NewRepository[*Account](
			eventStore,
			"Account",
			func(id string) *Account {
				return NewAccount(id)
			},
			func(agg *Account, event *eventsourcing.Event) error {
				msg, err := deserializeEventAccount(event)
				if err != nil {
					return err
				}
				return agg.ApplyEvent(msg)
			},
		),
	}
}

func deserializeEventAccount(event *eventsourcing.Event) (proto.Message, error) {
	switch event.EventType {
	case "bankaccount.AccountOpenedEvent":
		msg := &AccountOpenedEvent{}
		if err := proto.Unmarshal(event.Data, msg); err != nil {
			return nil, err
		}
		return msg, nil
	case "bankaccount.MoneyDepositedEvent":
		msg := &MoneyDepositedEvent{}
		if err := proto.Unmarshal(event.Data, msg); err != nil {
			return nil, err
		}
		return msg, nil
	default:
		return nil, fmt.Errorf("unknown event type: %s", event.EventType)
	}
}
```

## Step 4: Add Business Logic

Now you only need to fill in the business logic:

**domain/account.go**
```go
package domain

import (
	"errors"
	"math/big"
	pb "github.com/plaenen/eventstore/examples/bankaccount/proto"
)

// Add business logic methods to generated Account

func (a *pb.Account) calculateNewBalance(amount string) string {
	current, _ := new(big.Float).SetString(a.InitialBalance)
	add, _ := new(big.Float).SetString(amount)
	result := new(big.Float).Add(current, add)
	return result.Text('f', 2)
}

func (a *pb.Account) Withdraw(ctx context.Context, cmd *pb.WithdrawCommand, metadata eventsourcing.EventMetadata) error {
	// Business validation
	current, _ := new(big.Float).SetString(a.InitialBalance)
	withdraw, _ := new(big.Float).SetString(cmd.Amount)

	if current.Cmp(withdraw) < 0 {
		return errors.New("insufficient funds")
	}

	newBalance := new(big.Float).Sub(current, withdraw)

	event := &pb.MoneyWithdrawnEvent{
		AccountId:  cmd.AccountId,
		Amount:     cmd.Amount,
		NewBalance: newBalance.Text('f', 2),
		Timestamp:  time.Now().Unix(),
	}

	return a.ApplyChange(event, "bankaccount.MoneyWithdrawnEvent", metadata)
}
```

## Step 5: Implement Command Handlers

**handlers/command_handler.go**
```go
package handlers

import (
	"context"
	"github.com/plaenen/eventstore/pkg/eventsourcing"
	pb "github.com/plaenen/eventstore/examples/bankaccount/proto"
)

type AccountCommandHandler struct {
	repo *pb.AccountRepository
}

func NewAccountCommandHandler(repo *pb.AccountRepository) *AccountCommandHandler {
	return &AccountCommandHandler{repo: repo}
}

func (h *AccountCommandHandler) HandleOpenAccount(ctx context.Context, cmd *eventsourcing.CommandEnvelope) ([]*eventsourcing.Event, error) {
	openCmd := cmd.Command.(*pb.OpenAccountCommand)

	// Create new aggregate
	account := pb.NewAccount(openCmd.AccountId)
	account.SetCommandID(cmd.Metadata.CommandID)

	// Execute command
	if err := account.OpenAccount(ctx, openCmd, cmd.Metadata); err != nil {
		return nil, err
	}

	// Save with idempotency
	result, err := h.repo.SaveWithCommand(account, cmd.Metadata.CommandID)
	if err != nil {
		return nil, err
	}

	return result.Events, nil
}

func (h *AccountCommandHandler) HandleDeposit(ctx context.Context, cmd *eventsourcing.CommandEnvelope) ([]*eventsourcing.Event, error) {
	depositCmd := cmd.Command.(*pb.DepositCommand)

	// Load existing aggregate
	account, err := h.repo.Load(depositCmd.AccountId)
	if err != nil {
		return nil, err
	}

	account.SetCommandID(cmd.Metadata.CommandID)

	// Execute command
	if err := account.Deposit(ctx, depositCmd, cmd.Metadata); err != nil {
		return nil, err
	}

	// Save
	result, err := h.repo.SaveWithCommand(account, cmd.Metadata.CommandID)
	if err != nil {
		return nil, err
	}

	return result.Events, nil
}
```

## Step 6: Implement Projections

**projections/account_view.go**
```go
package projections

import (
	"context"
	"database/sql"
	"github.com/plaenen/eventstore/pkg/eventsourcing"
	pb "github.com/plaenen/eventstore/examples/bankaccount/proto"
)

type AccountViewProjection struct {
	db *sql.DB
}

func NewAccountViewProjection(db *sql.DB) *AccountViewProjection {
	return &AccountViewProjection{db: db}
}

func (p *AccountViewProjection) Name() string {
	return "account_view"
}

func (p *AccountViewProjection) Handle(ctx context.Context, event *eventsourcing.EventEnvelope) error {
	switch event.EventType {
	case "bankaccount.AccountOpenedEvent":
		var evt pb.AccountOpenedEvent
		if err := proto.Unmarshal(event.Data, &evt); err != nil {
			return err
		}
		return p.handleAccountOpened(&evt)

	case "bankaccount.MoneyDepositedEvent":
		var evt pb.MoneyDepositedEvent
		if err := proto.Unmarshal(event.Data, &evt); err != nil {
			return err
		}
		return p.handleMoneyDeposited(&evt)

	case "bankaccount.MoneyWithdrawnEvent":
		var evt pb.MoneyWithdrawnEvent
		if err := proto.Unmarshal(event.Data, &evt); err != nil {
			return err
		}
		return p.handleMoneyWithdrawn(&evt)
	}

	return nil
}

func (p *AccountViewProjection) handleAccountOpened(evt *pb.AccountOpenedEvent) error {
	_, err := p.db.Exec(`
		INSERT INTO account_view (account_id, owner_name, balance, status)
		VALUES (?, ?, ?, ?)
	`, evt.AccountId, evt.OwnerName, evt.InitialBalance, "OPEN")
	return err
}

func (p *AccountViewProjection) handleMoneyDeposited(evt *pb.MoneyDepositedEvent) error {
	_, err := p.db.Exec(`
		UPDATE account_view SET balance = ? WHERE account_id = ?
	`, evt.NewBalance, evt.AccountId)
	return err
}

func (p *AccountViewProjection) Reset(ctx context.Context) error {
	_, err := p.db.Exec(`DELETE FROM account_view`)
	return err
}
```

## Step 7: Wire Everything Together

**cmd/server/main.go**
```go
package main

import (
	"context"
	"log"
	"log/slog"
	"net/http"

	"github.com/plaenen/eventstore/pkg/eventsourcing"
	"github.com/plaenen/eventstore/pkg/sqlite"
	natspkg "github.com/plaenen/eventstore/pkg/nats"
	"github.com/plaenen/eventstore/pkg/middleware"

	pb "github.com/plaenen/eventstore/examples/bankaccount/proto"
	"github.com/plaenen/eventstore/examples/bankaccount/handlers"
	"github.com/plaenen/eventstore/examples/bankaccount/projections"
	"github.com/plaenen/eventstore/examples/bankaccount/proto/protoconnect"

	"connectrpc.com/connect"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
)

func main() {
	ctx := context.Background()
	logger := slog.Default()

	// 1. Setup Event Store
	eventStore, err := sqlite.NewEventStore(sqlite.DefaultConfig())
	if err != nil {
		log.Fatal(err)
	}
	defer eventStore.Close()

	// 2. Setup Event Bus (embedded NATS for dev)
	eventBus, natsServer, err := natspkg.NewEmbeddedEventBus()
	if err != nil {
		log.Fatal(err)
	}
	defer natsServer.Shutdown()
	defer eventBus.Close()

	// 3. Setup Command Bus
	commandBus := eventsourcing.NewCommandBusWithEventBus(eventBus)
	commandBus.Use(middleware.RecoveryMiddleware(logger))
	commandBus.Use(middleware.LoggingMiddleware(logger))
	commandBus.Use(middleware.OpenTelemetryMiddleware("bankaccount"))
	commandBus.Use(middleware.MetadataValidationMiddleware())

	// 4. Create Repository
	repo := pb.NewAccountRepository(eventStore)

	// 5. Register Command Handlers
	commandHandler := handlers.NewAccountCommandHandler(repo)
	commandBus.Register("bankaccount.OpenAccountCommand",
		eventsourcing.CommandHandlerFunc(commandHandler.HandleOpenAccount))
	commandBus.Register("bankaccount.DepositCommand",
		eventsourcing.CommandHandlerFunc(commandHandler.HandleDeposit))

	// 6. Setup Projections
	checkpointStore, _ := sqlite.NewCheckpointStore(eventStore.DB())
	projectionMgr := eventsourcing.NewProjectionManager(checkpointStore, eventStore, eventBus)

	accountView := projections.NewAccountViewProjection(eventStore.DB())
	projectionMgr.Register(accountView)
	projectionMgr.Start(ctx, "account_view")

	// 7. Setup Connect RPC Server
	mux := http.NewServeMux()

	// Command service
	commandService := &CommandServiceImpl{commandBus: commandBus}
	mux.Handle(protoconnect.NewAccountCommandServiceHandler(commandService))

	// Query service
	queryService := &QueryServiceImpl{db: eventStore.DB()}
	mux.Handle(protoconnect.NewAccountQueryServiceHandler(queryService))

	// 8. Start server
	logger.Info("Server starting on :8080")
	http.ListenAndServe(":8080", h2c.NewHandler(mux, &http2.Server{}))
}
```

## Result

With this setup, you get:

✅ **Auto-generated** aggregates, repositories, and event appliers
✅ **Type-safe** command and query handlers
✅ **Full CQRS** separation
✅ **Event sourcing** with SQLite
✅ **Real-time projections** via NATS
✅ **Idempotency** at all levels
✅ **Unique constraints** on account IDs
✅ **Connect RPC** API (HTTP/JSON + gRPC)

**You only write:**
- Business logic (validation, calculations)
- Projection handlers
- Service implementations

**Everything else is generated!**
